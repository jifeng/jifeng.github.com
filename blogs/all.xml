<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-路走对了，就不怕远</title><link>http://www.cnblogs.com/lengyuhong/</link><description /><language>zh-cn</language><lastBuildDate>Sun, 14 Apr 2013 07:21:45 GMT</lastBuildDate><pubDate>Sun, 14 Apr 2013 07:21:45 GMT</pubDate><ttl>60</ttl><item><title>Web开发中的缓存</title><link>http://www.cnblogs.com/lengyuhong/archive/2013/04/11/2993089.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 11 Apr 2013 11:11:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2013/04/11/2993089.html</guid><description><![CDATA[<p>《<!--StartFragment--><span>Web</span><span>开发中的缓存</span><!--EndFragment-->》是自己最近在团队中做的一次技术分享，大致梳理下在web中可能用到的相关缓存内容和自己的一些使用心得。</p>
<p>ppt重在整体的介绍，由于篇幅原因，细节没讲太深。</p>
<p>&nbsp;</p>
<p><object id="reader" width="630" height="500" align="middle" bgcolor="#FFFFFF" data="http://wenku.baidu.com/static/flash/apireader.swf?docurl=http://wenku.baidu.com/play&amp;docid=132abd0476c66137ee0619e1&amp;title=Web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98&amp;doctype=ppt&amp;fpn=5&amp;npn=5&amp;readertype=external&amp;catal=0&amp;cdnurl=http://txt.wenku.baidu.com/play" type="application/x-shockwave-flash"><param name="wmode" value="window" /><param name="allowfullscreen" value="true" /><param name="allowscriptaccess" value="always" /><param name="src" value="http://wenku.baidu.com/static/flash/apireader.swf?docurl=http://wenku.baidu.com/play&amp;docid=132abd0476c66137ee0619e1&amp;title=Web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98&amp;doctype=ppt&amp;fpn=5&amp;npn=5&amp;readertype=external&amp;catal=0&amp;cdnurl=http://txt.wenku.baidu.com/play" /><param name="pluginspage" value="http://www.macromedia.com/go/getflashplayer" /><param name="ver" value="9.0.0" /></object></p>
<p>ppt地址：http://wenku.baidu.com/view/132abd0476c66137ee0619e1.html</p>
<p>网页版ppt地址（建议用chrome访问）：http://jifeng.github.io/ppt/webcache.html&nbsp;</p>]]></description></item><item><title>fs.watch doesn't work</title><link>http://www.cnblogs.com/lengyuhong/archive/2013/04/08/3008812.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 08 Apr 2013 12:40:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2013/04/08/3008812.html</guid><description><![CDATA[<p>fafa</p>]]></description></item><item><title>用css实现footer</title><link>http://www.cnblogs.com/lengyuhong/archive/2013/04/03/2998095.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Wed, 03 Apr 2013 08:15:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2013/04/03/2998095.html</guid><description><![CDATA[<p>在html页面中，footer是非常有用，我们用它来标识它的版权和页面的相关信息。比如淘宝指数中的版权信息</p>
<p><img src="http://images.cnitblog.com/blog/311780/201304/03155454-6fb75da4b48346939b303aacae072adc.jpg" alt="" /></p>
<p>它的一个特点就是会&ldquo;固定&rdquo;在页面的尾部，并不会随这页面主内容少而跑上面去，当页面内容过多，超过一屏幕时，会紧跟在内容尾部，具体效果如图（来自网络）：</p>
<p><img src="http://ww3.sinaimg.cn/large/7013266egw1e3cfhjmj3oj.jpg" alt="" width="394" height="297" /></p>
<p>那怎么实现呢？其实很简单，只用设置css样式即可。</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 16px;">第一种方法</span></strong></p>
<p>HTML代码</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="container"</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="header"</span><span style="color: #0000ff;">&gt;</span>Header Section<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="body"</span><span style="color: #ff0000;"> class</span><span style="color: #0000ff;">="clearfix"</span><span style="color: #0000ff;">&gt;</span><span style="color: #000000;">
    页面容容部分
  </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="footer"</span><span style="color: #0000ff;">&gt;</span>Footer Section<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>CSS代码</p>
<div class="cnblogs_code">
<pre><span style="color: #800000;">html,body </span>{<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;">0</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 100%</span>;
}<span style="color: #800000;">
#container </span>{<span style="color: #ff0000;">
  min-height</span>:<span style="color: #0000ff;">100%</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> auto !important</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 100%</span>; <span style="color: #008000;">/*</span><span style="color: #008000;">IE6不识别min-height</span><span style="color: #008000;">*/</span><span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> relative</span>;
}<span style="color: #800000;">
#body </span>{<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 960px</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0 auto</span>;<span style="color: #ff0000;">
  padding-bottom</span>:<span style="color: #0000ff;"> 60px</span>;<span style="color: #008000;">/*</span><span style="color: #008000;">等于footer的高度</span><span style="color: #008000;">*/</span>
}<span style="color: #800000;">
#footer </span>{<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> absolute</span>;<span style="color: #ff0000;">
  bottom</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  width</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 60px</span>;<span style="color: #008000;">/*</span><span style="color: #008000;">脚部的高度</span><span style="color: #008000;">*/</span><span style="color: #ff0000;">
  clear</span>:<span style="color: #0000ff;">both</span>;
}</pre>
</div>
<p>&nbsp;</p>
<p>优点:<br />  结构简单清晰，无需js和任何hack能实现各浏览器下的兼容，同时在ipad、iphone下也可以正常运行</p>
<p>缺点：</p>
<p>1. 需要给div#footer容器设置一个固定高度<br />2. 需要将div#page容器的padding-bottom设置大于等于div#footer的高度</p>
<p>参考: http://matthewjamestaylor.com/blog/keeping-footers-at-the-bottom-of-the-page<br />DEMO: http://matthewjamestaylor.com/blog/bottom-footer-demo.htm</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;"><strong>第二种方法</strong></span></p>
<p><span style="font-size: 16px;">利用footer的margin-top负值来实现footer永远固定在页面的底部效果，原理和效果跟第一种方法是一样的</span></p>
<p>HTML代码</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="container"</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="header"</span><span style="color: #0000ff;">&gt;</span>Header Section<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="page"</span><span style="color: #0000ff;">&gt;</span>Main Content<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>  
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="footer"</span><span style="color: #0000ff;">&gt;</span>footer<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>&nbsp;</p>
<p>CSS代码</p>
<div class="cnblogs_code">
<pre><span style="color: #800000;">html,body </span>{<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;"> 0</span>;
}<span style="color: #800000;">
#container </span>{<span style="color: #ff0000;">
  min-height</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> auto !important</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 100%</span>;
}<span style="color: #800000;">
#footer </span>{<span style="color: #ff0000;">
  position</span>:<span style="color: #0000ff;"> relative</span>;<span style="color: #ff0000;">
  margin-top</span>:<span style="color: #0000ff;"> -60px</span>;<span style="color: #008000;">/*</span><span style="color: #008000;">等于footer的高度</span><span style="color: #008000;">*/</span><span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 60px</span>;<span style="color: #ff0000;">
  clear</span>:<span style="color: #0000ff;">both</span>;
}<span style="color: #800000;">
#page </span>{<span style="color: #ff0000;">
  padding-bottom</span>:<span style="color: #0000ff;"> 60px</span>;<span style="color: #008000;">/*</span><span style="color: #008000;">高度等于footer的高度</span><span style="color: #008000;">*/</span>
}</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;<strong><span style="font-size: 16px;">第三种方法</span></strong><span style="line-height: 1.5;">&nbsp;</span></p>
<p>HTML代码</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="container"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="page"</span><span style="color: #0000ff;">&gt;</span> Content <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">class</span><span style="color: #0000ff;">="push"</span><span style="color: #0000ff;">&gt;</span> 空标签<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">div </span><span style="color: #ff0000;">id</span><span style="color: #0000ff;">="footer"</span><span style="color: #0000ff;">&gt;</span>Footer<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">div</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>&nbsp;CSS代码</p>
<div class="cnblogs_code">
<pre><span style="color: #800000;">html,body</span>{<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;">0</span>;<span style="color: #ff0000;">
  padding</span>:<span style="color: #0000ff;">0</span>;
}<span style="color: #800000;">
#container </span>{<span style="color: #ff0000;">
  min-height</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> auto !important</span>;<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 100%</span>;<span style="color: #ff0000;">
  margin</span>:<span style="color: #0000ff;"> 0 auto -60px</span>;<span style="color: #008000;">/*</span><span style="color: #008000;">margin-bottom的负值等于footer高度</span><span style="color: #008000;">*/</span>
}<span style="color: #800000;">
.push, #footer </span>{<span style="color: #ff0000;">
  height</span>:<span style="color: #0000ff;"> 60px</span>;<span style="color: #ff0000;">
  clear</span>:<span style="color: #0000ff;">both</span>;
}</pre>
</div>
<p>&nbsp;</p>
<p>优点：</p>
<p>简单明了，易于理解，兼容所有浏览器。</p>
<p>缺点：</p>
<p>1.较之前面的两种方法，多使用了一个div.push容器</p>
<p>2.同样此方法限制了footer部分高度，无法达到自适应高度效果。</p>
<p>这种方法并不推荐使用</p>
<p>参考： <br />http://ryanfait.com/resources/footer-stick-to-bottom-of-page/</p>
<p>&nbsp;</p>
<p>补充：现在html5中已经增加了<a href="http://www.w3schools.com/tags/tag_footer.asp">footer标签</a>，在适当情况可以善用这个标签</p>
<p><span style="color: #ff0000;">声明：这篇文章并非完全原创，而且根据我同事田超强的分享文章整理所得。</span></p>]]></description></item><item><title>神奇的nextTick</title><link>http://www.cnblogs.com/lengyuhong/archive/2013/03/31/2987745.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 31 Mar 2013 08:52:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2013/03/31/2987745.html</guid><description><![CDATA[<p>在nodejs中，process.nextTick()可以说是个绕不开的地方，不然你都不好意思跟别人说你已经懂了nodejs的异步非阻塞特性了。</p>
<p><span style="font-size: 18px;"><strong>简介</strong></span></p>
<p>首先开听听nodejs中对nextTick的解释：</p>
<div class="cnblogs_code">
<pre>On the next loop around the <span style="color: #0000ff;">event</span> loop call <span style="color: #0000ff;">this</span> callback. This <span style="color: #0000ff;">is</span> not a simple alias to setTimeout(fn, <span style="color: #800080;">0</span>), it<span style="color: #800000;">'</span><span style="color: #800000;">s much more efficient</span></pre>
</div>
<p>可以清楚得看到，nextTick()达到的效果跟setTimeout(fn, 0)是一样，但为什么nextTick()会比setTimeout()更高效，不知道大家有没有想多这样的问题。</p>
<p>回答这个问题之前，大家要搞清楚nodejs中Tick的概念：<span>在libev中的event loop 的每次迭代，在nodejs 中就叫做 &ldquo;Tick&rdquo;。javascript是单进程运行的，具体到nodejs中，就是如图运行。</span></p>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/311780/201303/31161140-5ed5bcabdec34170ae80eabb008dcd33.png" alt="" /></p>
<p>如果用nextTick()话，它的执行时间是O(1), 而setTimeout(fn, 0)则是O(n)，考虑到篇幅，这里不再做具体的详述，有兴趣的朋友可以看<a href="http://cnodejs.org/topic/4f16442ccae1f4aa2700109b">《nodejs 异步之 Timer &amp;Tick; 篇》</a>一文，里面做了具体的解释。</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 18px;">应用场景</span></strong></p>
<p><span style="line-height: 1.5;">通过之前的介绍，可以看到nextTick()就是将某个任务放到下一个Tick中执行，简单讲就是延迟执行，那具体什么场景下需要用到这个功能呢？</span></p>
<p><strong><span style="font-size: 16px;">一. 同步emit时间，保证时序</span></strong></p>
<p><span>比如以下这段代码：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> EventEmitter = require('events'<span style="color: #000000;">).EventEmitter;

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> StreamLibrary(resourceName) { 
    </span><span style="color: #0000ff;">this</span>.emit('start'<span style="color: #000000;">);
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> read from the file, and for every chunk read, do: </span>
       <span style="color: #0000ff;">this</span>.emit('data'<span style="color: #000000;">, chunkRead); 
}
StreamLibrary.prototype.__proto__ </span>=<span style="color: #000000;"> EventEmitter.prototype;

</span><span style="color: #0000ff;">var</span> stream = <span style="color: #0000ff;">new</span> StreamLibrary('fooResource'<span style="color: #000000;">);
stream.on(</span>'start', <span style="color: #0000ff;">function</span><span style="color: #000000;">() {
    console.log(</span>'Reading has started'<span style="color: #000000;">);
});

stream.on(</span>'data', <span style="color: #0000ff;">function</span><span style="color: #000000;">(chunk) {
    console.log(</span>'Received: ' +<span style="color: #000000;"> chunk);
});</span></pre>
</div>
<p>从代码本身来看没什么问题，但事实是：我们可能永远也监听不到"start"事件，因为这个事件在调用构造函数时，已经马上抛出了这个事件。</p>
<p><span>那解决方案就是让'start'延时执行，具体如下：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> StreamLibrary(resourceName) { 
   </span><span style="color: #0000ff;">var</span> self = <span style="color: #0000ff;">this</span><span style="color: #000000;">;
   process.nextTick(</span><span style="color: #0000ff;">function</span><span style="color: #000000;">() {
     self.emit(</span>'start'<span style="color: #000000;">);
});

   </span><span style="color: #008000;">//</span><span style="color: #008000;"> read from the file, and for every chunk read, do: </span>
       <span style="color: #0000ff;">this</span>.emit('data'<span style="color: #000000;">, chunkRead); 
}</span></pre>
</div>
<p>&nbsp;</p>
<p>其实早nodejs的源码也存在大量这样的用法，比如net模块</p>
<div class="cnblogs_code">
<pre>    require('dns').lookup(host, <span style="color: #0000ff;">function</span><span style="color: #000000;">(err, ip, addressType) {
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> It's possible we were destroyed while looking this up.</span>
      <span style="color: #008000;">//</span><span style="color: #008000;"> XXX it would be great if we could cancel the promise returned by</span>
      <span style="color: #008000;">//</span><span style="color: #008000;"> the look up.</span>
      <span style="color: #0000ff;">if</span> (!self._connecting) <span style="color: #0000ff;">return</span><span style="color: #000000;">;

      </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (err) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> net.createConnection() creates a net.Socket object and</span>
        <span style="color: #008000;">//</span><span style="color: #008000;"> immediately calls net.Socket.connect() on it (that's us).</span>
        <span style="color: #008000;">//</span><span style="color: #008000;"> There are no event listeners registered yet so defer the</span>
        <span style="color: #008000;">//</span><span style="color: #008000;"> error event to the next tick.</span>
        process.nextTick(<span style="color: #0000ff;">function</span><span style="color: #000000;">() {
          self.emit(</span>'error'<span style="color: #000000;">, err);
          self._destroy();
        });
      }</span></pre>
</div>
<p>这里的err处理就是出于这样的目的。</p>
<p>具体代码连接：<em id="__mceDel">https://github.com/joyent/node/blob/master/lib/net.js#L806</em></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: 16px;">二. cpu高密集代码段</span></strong></p>
<p>由于javascript是单进程的，当一个cpu被一个任务任务跑满时，它是不能执行其他任务的，在web服务中，这点甚至是致命，如果它被一个cpu密集的任务占满，那就不能相应其他的请求了，程序相当于&ldquo;假死&rdquo;。</p>
<p>这个时候，将这个任务推迟执行倒不失为一个不错的选择。</p>
<p>比如：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> http = require('http'<span style="color: #000000;">);

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> compute() {
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 执行一个cpu密集的任务</span>
   <span style="color: #008000;">//</span><span style="color: #008000;"> ...</span>
<span style="color: #000000;">   process.nextTick(compute);
}

http.createServer(</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(req, res) {
   res.writeHead(</span>200, {'Content-Type': 'text/plain'<span style="color: #000000;">});
   res.end(</span>'Hello World'<span style="color: #000000;">);
}).listen(</span>5000, '127.0.0.1'<span style="color: #000000;">);

compute();</span></pre>
</div>
<p>&nbsp;</p>
<p>但问题又来，我们怎么去界定哪些任务是需要推迟推迟执行，而那些则不需要，有什么量化的标准吗？</p>
<p>对不起，我暂时也没有特别好的方法。执行时间是个很好的判断标准，到底是1毫秒，1秒，还是10秒.......,并有很好的量化标准</p>
<p>所以我的感受是：在你懂得nextTick的原理后，根据自己的业务场景来决定。</p>
<p>&nbsp;</p>
<p>经典文章：<br /><a href="http://howtonode.org/understanding-process-next-tick">Understanding process.nextTick()</a><br /><a href="http://cnodejs.org/topic/4f16442ccae1f4aa2700109b">nextTick and setTimeout</a><br /><a href="https://gist.github.com/mmalecki/1257394">test case about nextTick and setTimeout</a></p>]]></description></item><item><title>关于作者</title><link>http://www.cnblogs.com/lengyuhong/archive/2013/03/24/2516776.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 24 Mar 2013 08:52:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2013/03/24/2516776.html</guid><description><![CDATA[<p><span style="font-size: 14pt; color: #00ffff;">about</span></p>
<p>朱佳墩&nbsp;<br />淘宝花名：<span class="weibo">&nbsp;<a href="http://weibo.com/lengyuhong" target="_blank">继风</a>&nbsp;</span></p>
<p>web开发工程师，现就职于淘宝数据平台与产品部，居住在人间天堂杭州。主要爱好研究研究NoSQL数据库，nodejs和web前端开发等技术。&nbsp;<br />工程师中的文艺青年，代码，阅读，行走，电影，现在差不多是我现在生活的全部。</p>
<p>&nbsp;<img src="http://images.cnitblog.com/blog/311780/201303/24164742-39e928dcc3874d2aa71dc6af9fb90d9a.jpg" alt="" /></p>
<div id="pic">&nbsp;</div>
<div id="contact_about" class="cc">联系方式</div>
<div id="contact" class="cc">
<ul>
<li><span style="font-size: 14px;">微博:<a href="http://weibo.com/lengyuhong" target="_blank">&nbsp;继风Jordan</a></span></li>
<li><span style="font-size: 14px;">豆瓣：<a href="http://www.douban.com/people/lengyuhong/">冷羽鸿</a></span></li>
<li><span style="font-size: 14px;">github:&nbsp;<a href="https://github.com/jifeng" target="_blank">jifeng</a></span></li>
<li><span style="font-size: 14px;">mail:wade428@163.com</span></li>






</ul>










</div>
<p>&nbsp;</p>
<p>&nbsp;&ldquo;路走对了，就不怕远&rdquo;</p>]]></description></item><item><title>cookie的作用域</title><link>http://www.cnblogs.com/lengyuhong/archive/2013/02/26/2934078.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Tue, 26 Feb 2013 12:54:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2013/02/26/2934078.html</guid><description><![CDATA[<p>前阵子，接一个用户授权服务时,遇到一个关于cookie的诡异问题，折腾了一天才知道问题出在哪儿，虽然时候才知道这是个小白问题。</p>
<p>遇到问题是这样子：</p>
<p>&nbsp; &nbsp; &nbsp;比如访问A地址（比如http://localhost/index，http://localhost/test/index)时需要登陆时会跳转到一个登陆页面，登陆成功后，跳转回原页面，这时将用户信息存入到session中，并通过response的Set-Cookie头信息，设置向对应的cookie值。具体如下：</p>
<div class="cnblogs_code">
<pre>Set-Cookie:sid=Wnse42HlgkYBbLtAEOMRkXcWHSwkr9nRUS0WBFFHA4TCZUga; Max-Age=<span style="color: #800080;">28800</span>; Expires=Mon, <span style="color: #800080;">18</span> Mar <span style="color: #800080;">2013</span> <span style="color: #800080;">12</span>:<span style="color: #800080;">07</span>:<span style="color: #800080;">32</span> GMT; </pre>
</div>
<p>&nbsp; &nbsp; &nbsp;乍一看没有问题吧？</p>
<p>&nbsp; &nbsp; &nbsp;当A地址是在一级目录，比如http://localhost/index，这样是没有任何问题的。</p>
<p>&nbsp; &nbsp; &nbsp;但A地址是在二级目录，比如http://localhost/test/index，问题就来了。访问过A后再去访问其他层级的目录，比如http://localhost/test2/index，这时是得不到用户的cookie信息，就好像之前的登陆无效一样。</p>
<p>现在大家应该清楚问题处在哪了？<strong>cookie的作用域问题</strong>。</p>
<p>解决方法也很简单，指定全局的作用域</p>
<div class="cnblogs_code">
<pre>Set-Cookie:sid=Wnse42HlgkYBbLtAEOMRkXcWHSwkr9nRUS0WBFFHA4TCZUga; Max-Age=<span style="color: #800080;">28800</span>; Expires=Mon, <span style="color: #800080;">18</span> Mar <span style="color: #800080;">2013</span> <span style="color: #800080;">12</span>:<span style="color: #800080;">07</span>:<span style="color: #800080;">32</span> GMT; Path=/;</pre>
</div>
<p>&nbsp;这里很重要的一点是：<span>正常的</span><strong>cookie</strong><span>只能在一个应用中（简单理解，就是一个目录）共享，即一个</span><strong>cookie</strong><span>只能由创建它的应用获得，比如在/test1/*创建自己应用的cookie，/test2/*下是拿不到。而且很容易被忽视的一点：<strong>path默认是产生cookie</strong><span><strong>的应用的路径</strong>。</span></span></p>
<p><span><span>如果两者需要共享的话，指定Path为"/"即可</span></span></p>
<p>所以以前千万不要为了省事，而不设置一些重要的参数，不然......</p>
<p>具体的测试代码可见：https://github.com/jifeng/toycode/blob/master/cookie/path.js</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;&nbsp;</p>
<div class="header-name">&nbsp;</div>
<p>&nbsp;</p>]]></description></item><item><title>谈谈javascript的作用域链和this</title><link>http://www.cnblogs.com/lengyuhong/archive/2013/02/04/2892093.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 04 Feb 2013 09:56:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2013/02/04/2892093.html</guid><description><![CDATA[<p>作用域和this绝对是javascript中最容易让人栽跟头的地方之一，闲话少说，先问题个问题？</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> a =<span style="color: #000000;"> {
  b: </span>1<span style="color: #000000;">,
  c: </span><span style="color: #0000ff;">function</span><span style="color: #000000;">() {
    alert(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.b.toString());
  }
}
a.c();

b </span>=<span style="color: #000000;"> a.c
b();<br /></span></pre>
</div>
<p>思考下，再看后面的答案。是不是觉得是：</p>
<div class="cnblogs_code">
<pre><span>1<br />1</span></pre>
</div>
<p>公布正确答案</p>
<div class="cnblogs_code">
<pre>1
<span style="color: #0000ff;">function</span><span style="color: #000000;"> () {
    console.log(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.b.toString());
}</span></pre>
</div>
<p>再看下面这段程序：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span><span style="color: #000000;"> b;
</span><span style="color: #0000ff;">var</span> a =<span style="color: #000000;"> {
  b: </span>1<span style="color: #000000;">,
  c: </span><span style="color: #0000ff;">function</span><span style="color: #000000;">() {
    alert(b);
  }
}
a.c();

b </span>=<span style="color: #000000;"> a.c
b();</span></pre>
</div>
<p>正确答案：</p>
<div class="cnblogs_code">
<p>undefined<br />[Function]</p>


</div>
<p>ps:如果你一下子就能答出两道题正确答案，说明你已经比较掌握this的使用，本文可能并不适合你，可以不需要再看接下来的内容</p>
<p>言归正传,为什么是这样的运行结果呢？</p>
<p>主要请记住重要的这么几点：</p>
<p><span>* <strong>JavaScript中的函数运行在它们被定义的作用域里,而不是它们被执行的作用域里</strong></span></p>
<p><strong>*&nbsp;那就是this指的是，调用函数的那个对象</strong></p>
<p>第一道题中调用b()时，this已经指向全局，所以this.b就是一个函数</p>
<p>第二道题中a.c()和b()得到的是作用域链最外层的全局变量b</p>
<p>&nbsp;</p>
<p>参考文章：</p>
<p class="p1">作用域链：<span class="s1"><a href="http://www.laruence.com/2009/05/28/863.html">http://www.laruence.com/2009/05/28/863.html</a></span></p>
<p class="p1">this用法：<span class="s1"><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html</a></span></p>]]></description></item><item><title>siege用法</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/08/14/2638272.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Tue, 14 Aug 2012 09:00:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/08/14/2638272.html</guid><description><![CDATA[<p>相信大家对siege还是比较了解的，它是一款比较功能比较强大的压力测试软件。可能大家平常也会用，但直到前阵子，发现自己对它的参数理解还不够深刻，分享出来希望对大家有所帮助。</p>
<p>如果我用以下这样的参数去进行压力测试，具体是怎样的？</p>
<div class="cnblogs_code">
<pre>siege -r1000 -c20  <span style="color: #800000;">"</span><span style="color: #800000;">127.0.0.1:1823</span><span style="color: #800000;">"</span></pre>
</div>
<p>是不是&ldquo;20个并发用户，每个用户重复请求1000次，去压本地的1823端口&rdquo;。</p>
<p>好的，那接下来的问题来了，每个用户的每个请求之间会不会有延时？如果有延时的话，会不会对得到的性能指标有所影响呢？</p>
<p>这就我们之前很可能忽视的一个参数：</p>
<div class="cnblogs_code">
<pre>-b, --benchmark         BENCHMARK: no delays between requests.</pre>
</div>
<div class="cnblogs_code">
<pre>&lsquo; &ndash;delay=<span style="color: #000000;">NUM &lsquo;
Each siege simulated user is delayed </span><span style="color: #0000ff;">for</span> a random number of seconds between one and NUM. If you are benchmarking performance, it is recommended that you use a <span style="color: #800080;">1</span> second delay ( -d1 ). The default value is three (<span style="color: #800080;">3</span> ). This delay allows <span style="color: #0000ff;">for</span> the transactions to stagger rather <span style="color: #0000ff;">then</span> to allow them to pound the server <span style="color: #0000ff;">in</span> waves.</pre>
</div>
<p>&nbsp;</p>
<p>所以正确的压力测试参数应该是：</p>
<div class="cnblogs_code">
<pre>siege -r1000 -c20 -b  <span style="color: #800000;">"</span><span style="color: #800000;">127.0.0.1:1823</span><span style="color: #800000;">"</span></pre>
</div>
<p>&nbsp;</p>
<p>参考文章：</p>
<p><a href="http://www.php-oa.com/2010/06/25/siege.html">http://www.php-oa.com/2010/06/25/siege.html</a></p>]]></description></item><item><title>再谈压力测试——并发连接数</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/08/14/2638231.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Tue, 14 Aug 2012 08:20:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/08/14/2638231.html</guid><description><![CDATA[<p>&nbsp; &nbsp; 之前</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>Node.js中的response优化</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/07/06/2579820.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Fri, 06 Jul 2012 09:58:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/07/06/2579820.html</guid><description><![CDATA[<p>&nbsp; &nbsp; Nodejs中request和response是最常打交道的两个两个</p>]]></description></item><item><title>高性能服务器</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/07/05/2577745.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 05 Jul 2012 06:09:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/07/05/2577745.html</guid><description><![CDATA[<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>常见的I/O模型</p>
<p>&nbsp;</p>
<p>-异步IO</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>cache</p>
<p>&nbsp; cpu密集的操作，指针cachaeline对齐</p>
<p>&nbsp; 共享数据 cache flash sharing</p>
<p>&nbsp;</p>
<p>内存池</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>MongoDB中query当key时的错误</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/28/2563657.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 28 Jun 2012 12:04:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/28/2563657.html</guid><description><![CDATA[<p>&nbsp; &nbsp; 最近在操作MongoDB时，遇到一个比较坑爹的问题，就是将&ldquo;query&rdquo;当做一条的记录，它在一些条件下就&ldquo;失效&rdquo;。</p>
<p>&nbsp; &nbsp; 我使用的MongoDB数据库版本是1.8.3。MongoDB shell version: 2.0.3</p>
<p>&nbsp; &nbsp; 具体数据：</p>
<div class="cnblogs_code">
<pre>{ "_id" : ObjectId("4fe955021219143f31b9d2b9"), "query" : 1, "test" : [ 1, 2, 3<span style="color: #000000;"> ] }
{ </span>"_id" : ObjectId("4fe9557b1219143f31b9d2ba"), "q" : 1, "r" : 2<span style="color: #000000;"> }
{ </span>"_id" : ObjectId("4fe955b11219143f31b9d2bb"), "query1" : 1, "r" : 2 }</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;在正常的key value查找时没有任何问题：</p>
<div class="cnblogs_code">
<pre>PRIMARY&gt; db.testin.find({query: 1<span style="color: #000000;">})
{ </span>"_id" : ObjectId("4fe955021219143f31b9d2b9"), "query" : 1, "test" : [ 1, 2, 3<span style="color: #000000;"> ] }
PRIMARY</span>&gt; db.testin.find({q: 1<span style="color: #000000;">})
{ </span>"_id" : ObjectId("4fe9557b1219143f31b9d2ba"), "q" : 1, "r" : 2<span style="color: #000000;"> }
PRIMARY</span>&gt; db.testin.find({quer1: 1})</pre>
</div>
<p>&nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;用or逻辑查找也没有问题：</p>
<div class="cnblogs_code">
<pre>PRIMARY&gt; db.testin.find({$or:[{query: 1<span style="color: #000000;">}]})
{ </span>"_id" : ObjectId("4fe955021219143f31b9d2b9"), "query" : 1, "test" : [ 1, 2, 3<span style="color: #000000;"> ] }
PRIMARY</span>&gt; db.testin.find({$or:[{q: 1<span style="color: #000000;">}]})
{ </span>"_id" : ObjectId("4fe9557b1219143f31b9d2ba"), "q" : 1, "r" : 2<span style="color: #000000;"> }
PRIMARY</span>&gt; db.testin.find({$or:[{query1: 1<span style="color: #000000;">}]})
{ </span>"_id" : ObjectId("4fe955b11219143f31b9d2bb"), "query1" : 1, "r" : 2 }</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;但用in逻辑查找时，就出现query作为key的文档找不到，具体如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #ff0000;">PRIMARY&gt; db.testin.find({query: {$in: [1</span><span style="color: #000000;"><span style="color: #ff0000;">]}})</span>
PRIMARY</span>&gt; db.testin.find({query1: {$<span style="color: #0000ff;">in</span>: [1<span style="color: #000000;">]}})
{ </span>"_id" : ObjectId("4fe955b11219143f31b9d2bb"), "query1" : 1, "r" : 2<span style="color: #000000;"> }
PRIMARY</span>&gt; db.testin.find({q: {$<span style="color: #0000ff;">in</span>: [1<span style="color: #000000;">]}})
{ </span>"_id" : ObjectId("4fe9557b1219143f31b9d2ba"), "q" : 1, "r" : 2 }</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;个人感觉这应该算是个bug，造成的具体原因还在寻找过程中，今天先把这个问题抛出来，有过这方面经验的大牛，希望能指教一下。谢谢</p>]]></description></item><item><title>javascript超链接</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/28/2567222.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 28 Jun 2012 02:36:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/28/2567222.html</guid><description><![CDATA[<h3><a href="http://jacki6.iteye.com/blog/477958">IE6下&lt;a href="#"&gt;与&lt;a href="javascript:void(0);"&gt;的区别</a></h3>
<p><a href="http://hi.baidu.com/fc_lamp/blog/item/6d83adca8f1fca16be09e6ca.html/cmtid/00e81b10b9a43200b9127bef">http://hi.baidu.com/fc_lamp/blog/item/6d83adca8f1fca16be09e6ca.html/cmtid/00e81b10b9a43200b9127bef</a></p>
<p>&nbsp;</p>
<p><a href="http://stackoverflow.com/questions/3666683/href-javascript-vs-href-javascriptvoid0">http://stackoverflow.com/questions/3666683/href-javascript-vs-href-javascriptvoid0</a></p>]]></description></item><item><title>如何快速测试代码的执行效率</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/27/2565667.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Wed, 27 Jun 2012 05:32:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/27/2565667.html</guid><description><![CDATA[<p><span>要测试javascript代码执行效率，当然有很多方法，今天听了</span><a href="http://weibo.com/q3boy" target="_blank">清笃</a><span>&nbsp;的一个技术分享，发现之前一直忽略了一个最简单快速的方法：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">console.time(name)
Creates a </span><span style="color: #0000ff;">new</span> timer under the given name. Call console.timeEnd(name) <span style="color: #0000ff;">with</span><span style="color: #000000;"> the same name to      stop the timer and print the time elapsed..

console.timeEnd(name)
Stops a timer created by a call to console.time(name) and writes the time elapsed.</span></pre>
</div>
<p>比如：</p>
<div class="cnblogs_code">
<pre>console.time('a'<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">你要测试效率的代码</span>
<span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = 0; i &lt; 1000000; i++<span style="color: #000000;">) {
}
console.timeEnd(</span>'a');</pre>
</div>
<p>&nbsp;</p>
<p>执行结果：</p>
<p>a: 3ms</p>
<p><span>&nbsp;</span></p>]]></description></item><item><title>mongodb优化</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/21/2557796.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 21 Jun 2012 07:15:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/21/2557796.html</guid><description><![CDATA[<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>db.bind(<span style="color: #800000;">'</span><span style="color: #800000;">associated_query</span><span style="color: #800000;">'</span><span style="color: #000000;">, {
  </span><span style="color: #008000;">//</span><span style="color: #008000;">新增或者更新这对query词</span>
<span style="color: #000000;">  saveCompare: function (query, associatedQuery, callback) {
    </span><span style="color: #0000ff;">var</span> findQuery =<span style="color: #000000;"> {query: {$all: [query, associatedQuery]}};
    </span><span style="color: #0000ff;">var</span> doc =<span style="color: #000000;"> {
      $</span><span style="color: #0000ff;">set</span><span style="color: #000000;">: {query: [query, associatedQuery]},
      $inc: { visitcount: </span><span style="color: #800080;">1</span><span style="color: #000000;"> }
    };
    </span><span style="color: #0000ff;">this</span>.update(findQuery, doc, { upsert: <span style="color: #0000ff;">true</span> }, callback ||<span style="color: #000000;"> noop);
  },
  </span><span style="color: #008000;">//</span><span style="color: #008000;">得到关联搜索词, 默认是三个关键词</span>
<span style="color: #000000;">  fetchAssociatedQuery: function (query, limitNum, callback) {
    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> limitNum === <span style="color: #800000;">'</span><span style="color: #800000;">function</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
      callback </span>=<span style="color: #000000;"> limitNum;
      limitNum </span>= <span style="color: #800080;">3</span><span style="color: #000000;">; 
    }
    </span><span style="color: #0000ff;">this</span>.find({query: query}, {limit: limitNum, sort: [[<span style="color: #800000;">'</span><span style="color: #800000;">visitcount</span><span style="color: #800000;">'</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">]]})
    .toArray(function (err, items) {
      </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (err) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> callback(err);
      }
      </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">items) {
        </span><span style="color: #0000ff;">return</span> callback(<span style="color: #0000ff;">null</span><span style="color: #000000;">, []);
      } 
      </span><span style="color: #0000ff;">var</span> rows =<span style="color: #000000;"> [];
      </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, l = items.length; i &lt; l; i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">var</span> item =<span style="color: #000000;"> items[i];
        </span><span style="color: #0000ff;">if</span> (item &amp;&amp; item.query &amp;&amp; item.query.length &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) {
          </span><span style="color: #0000ff;">if</span> (item.query[<span style="color: #800080;">0</span>] !==<span style="color: #000000;"> query) {
            rows.push(item.query[</span><span style="color: #800080;">0</span><span style="color: #000000;">]);
          } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            rows.push(item.query[</span><span style="color: #800080;">1</span><span style="color: #000000;">]);
          }
        }
      }
      callback(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">, rows);
    });
  },
  fetchAssociatedQueryBatch: function (queries, callback) {
    </span><span style="color: #0000ff;">var</span> newAssociatedQueries =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">var</span> findQuery =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">var</span> flagQuries =<span style="color: #000000;"> {};
    </span><span style="color: #0000ff;">var</span> len =<span style="color: #000000;"> queries.length;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>; i &lt; len; i++<span style="color: #000000;">) {
      </span><span style="color: #0000ff;">var</span> query =<span style="color: #000000;"> queries[i];
      flagQuries[query] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
      findQuery.push({query: query});
    }
    </span><span style="color: #0000ff;">var</span> sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>.find({$or: findQuery}, {sort: [[<span style="color: #800000;">'</span><span style="color: #800000;">visitcount</span><span style="color: #800000;">'</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">]]})
    .toArray(function (err, rows) {
      </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (err) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> callback(err);
      }
      </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>; i &lt; rows.length; i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">var</span> item =<span style="color: #000000;"> rows[i];
        </span><span style="color: #0000ff;">if</span> (item &amp;&amp; item.query &amp;&amp; item.query.length &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) { 
          </span><span style="color: #0000ff;">var</span> query =<span style="color: #000000;"> item.query;
          </span><span style="color: #0000ff;">if</span> (flagQuries[query[<span style="color: #800080;">0</span>]] === <span style="color: #800080;">0</span><span style="color: #000000;">) {
            flagQuries[query[</span><span style="color: #800080;">0</span>]] = query[<span style="color: #800080;">1</span><span style="color: #000000;">];
            sum</span>++<span style="color: #000000;">;
          }
          </span><span style="color: #0000ff;">if</span> (flagQuries[query[<span style="color: #800080;">1</span>]] === <span style="color: #800080;">0</span><span style="color: #000000;">) {
            flagQuries[query[</span><span style="color: #800080;">1</span>]] = query[<span style="color: #800080;">0</span><span style="color: #000000;">];
            sum</span>++<span style="color: #000000;">;
          }
        }
        </span><span style="color: #0000ff;">if</span> (sum ===<span style="color: #000000;"> len) {
          </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
      }
      </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>; i &lt; len; i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">var</span> query =<span style="color: #000000;"> queries[i];
        newAssociatedQueries.push(flagQuries[query] </span>=== <span style="color: #800080;">0</span> ?<span style="color: #000000;"> undefined : flagQuries[query]);
      }
      callback(err, newAssociatedQueries);
    });
  }
});</span></pre>
</div>
<div class="cnblogs_code">
<pre>db.bind(<span style="color: #800000;">'</span><span style="color: #800000;">associated_query</span><span style="color: #800000;">'</span><span style="color: #000000;">, {
  </span><span style="color: #008000;">//</span><span style="color: #008000;">新增或者更新这对query词</span>
<span style="color: #000000;">  saveCompare: function (query, associatedQuery, callback) {
    </span><span style="color: #0000ff;">var</span> findQuery =<span style="color: #000000;"> {query: {$all: [query, associatedQuery]}};
    </span><span style="color: #0000ff;">var</span> doc =<span style="color: #000000;"> {
      $</span><span style="color: #0000ff;">set</span><span style="color: #000000;">: {query: [query, associatedQuery]},
      $inc: { visitcount: </span><span style="color: #800080;">1</span><span style="color: #000000;"> }
    };
    </span><span style="color: #0000ff;">this</span>.update(findQuery, doc, { upsert: <span style="color: #0000ff;">true</span> }, callback ||<span style="color: #000000;"> noop);
  },
  </span><span style="color: #008000;">//</span><span style="color: #008000;">得到关联搜索词, 默认是三个关键词</span>
<span style="color: #000000;">  fetchAssociatedQuery: function (query, limitNum, callback) {
    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">typeof</span> limitNum === <span style="color: #800000;">'</span><span style="color: #800000;">function</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
      callback </span>=<span style="color: #000000;"> limitNum;
      limitNum </span>= <span style="color: #800080;">3</span><span style="color: #000000;">; 
    }
    </span><span style="color: #0000ff;">this</span>.find({query: query}, {limit: limitNum, sort: [[<span style="color: #800000;">'</span><span style="color: #800000;">visitcount</span><span style="color: #800000;">'</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">]]})
    .toArray(function (err, items) {
      </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (err) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> callback(err);
      }
      </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">items) {
        </span><span style="color: #0000ff;">return</span> callback(<span style="color: #0000ff;">null</span><span style="color: #000000;">, []);
      } 
      </span><span style="color: #0000ff;">var</span> rows =<span style="color: #000000;"> [];
      </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>, l = items.length; i &lt; l; i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">var</span> item =<span style="color: #000000;"> items[i];
        </span><span style="color: #0000ff;">if</span> (item &amp;&amp; item.query &amp;&amp; item.query.length &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) {
          </span><span style="color: #0000ff;">if</span> (item.query[<span style="color: #800080;">0</span>] !==<span style="color: #000000;"> query) {
            rows.push(item.query[</span><span style="color: #800080;">0</span><span style="color: #000000;">]);
          } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            rows.push(item.query[</span><span style="color: #800080;">1</span><span style="color: #000000;">]);
          }
        }
      }
      callback(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">, rows);
    });
  },
  fetchAssociatedQueryBatch: function (queries, callback) {
    </span><span style="color: #0000ff;">var</span> newAssociatedQueries =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">var</span> findQuery =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">var</span> flagQuries =<span style="color: #000000;"> {};
    </span><span style="color: #0000ff;">var</span> len =<span style="color: #000000;"> queries.length;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>; i &lt; len; i++<span style="color: #000000;">) {
      </span><span style="color: #0000ff;">var</span> query =<span style="color: #000000;"> queries[i];
      flagQuries[query] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
      findQuery.push({query: query});
    }
    </span><span style="color: #0000ff;">var</span> sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">this</span>.find({$or: findQuery}, {sort: [[<span style="color: #800000;">'</span><span style="color: #800000;">visitcount</span><span style="color: #800000;">'</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">]]})
    .toArray(function (err, rows) {
      </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (err) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> callback(err);
      }
      </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>; i &lt; rows.length; i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">var</span> item =<span style="color: #000000;"> rows[i];
        </span><span style="color: #0000ff;">if</span> (item &amp;&amp; item.query &amp;&amp; item.query.length &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) { 
          </span><span style="color: #0000ff;">var</span> query =<span style="color: #000000;"> item.query;
          </span><span style="color: #0000ff;">if</span> (flagQuries[query[<span style="color: #800080;">0</span>]] === <span style="color: #800080;">0</span><span style="color: #000000;">) {
            flagQuries[query[</span><span style="color: #800080;">0</span>]] = query[<span style="color: #800080;">1</span><span style="color: #000000;">];
            sum</span>++<span style="color: #000000;">;
          }
          </span><span style="color: #0000ff;">if</span> (flagQuries[query[<span style="color: #800080;">1</span>]] === <span style="color: #800080;">0</span><span style="color: #000000;">) {
            flagQuries[query[</span><span style="color: #800080;">1</span>]] = query[<span style="color: #800080;">0</span><span style="color: #000000;">];
            sum</span>++<span style="color: #000000;">;
          }
        }
        </span><span style="color: #0000ff;">if</span> (sum ===<span style="color: #000000;"> len) {
          </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
      }
      </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = <span style="color: #800080;">0</span>; i &lt; len; i++<span style="color: #000000;">) {
        </span><span style="color: #0000ff;">var</span> query =<span style="color: #000000;"> queries[i];
        newAssociatedQueries.push(flagQuries[query] </span>=== <span style="color: #800080;">0</span> ?<span style="color: #000000;"> undefined : flagQuries[query]);
      }
      callback(err, newAssociatedQueries);
    });
  }
});</span></pre>
</div>]]></description></item><item><title>jscoverage 原理</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/20/2556036.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Wed, 20 Jun 2012 03:50:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/20/2556036.html</guid><description><![CDATA[<p>jscoverage 原理</p>]]></description></item><item><title>mongodb 联合索引</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/18/2553799.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 18 Jun 2012 09:02:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/18/2553799.html</guid><description><![CDATA[<p><a href="http://www.mongodb.org/display/DOCS/Indexes">http://www.mongodb.org/display/DOCS/Indexes</a></p>
<p>&nbsp;</p>
<p><a href="http://blog.nosqlfan.com/html/3132.html">http://blog.nosqlfan.com/html/3132.html</a></p>
<p>&nbsp;</p>
<p>mysql索引原理</p>
<p><a href="http://www.codinglabs.org/html/theory-of-mysql-index.html">http://www.codinglabs.org/html/theory-of-mysql-index.html</a></p>]]></description></item><item><title>nodejs querystring.parse中url解码</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/18/2553528.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 18 Jun 2012 06:17:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/18/2553528.html</guid><description><![CDATA[<pre class="reviewtext"><a href="https://github.com/joyent/node/blob/master/lib/querystring.js#L161" target="_blank">https://github.com/joyent/node/blob/master/lib/querystring.js#L161</a></pre>]]></description></item><item><title>javascript正则表达式</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/18/2553521.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 18 Jun 2012 06:13:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/18/2553521.html</guid><description><![CDATA[<p>/^(\/searchindex(\/)?|\/tradeindex(\/)?|\/trendindex(\/)?)/</p>
<p><a href="http://www.cainiao8.com/web/js_note/js_regular_expression.html">http://www.cainiao8.com/web/js_note/js_regular_expression.html</a></p>]]></description></item><item><title>jQuery中live，delegate底层实现的区别</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/17/2552879.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 17 Jun 2012 13:36:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/17/2552879.html</guid><description><![CDATA[<p>那么delegate和live在实现到底还有哪些区别？</p>
<p>&nbsp; &nbsp; 查了jQuery的源代码，才发现原来，他们的底层实现在jquery1.7之前竟然是同一套实现，delegate只是在live上做了一次封装：</p>
<div class="cnblogs_code">
<pre>delegate: <span>function</span><span> (a, b, c, d) {
</span><span>  return</span> <span>this</span><span>.live(b, c, d, a)
}</span></pre>
</div>
<p>&nbsp; &nbsp; 具体参见：<a href="http://code.jquery.com/jquery-1.6.4.js">http://code.jquery.com/jquery-1.6.4.js</a></p>]]></description></item><item><title>再谈jQuery中.live()和.delegate()之间的区别</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/17/2550178.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 17 Jun 2012 13:25:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/17/2550178.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp;之前看了这篇文章<span style="text-decoration: underline; color: #0000ff;"><em><span style="text-decoration: underline;"><a href="http://www.alfajango.com/blog/the-difference-between-jquerys-bind-live-and-delegate/"><span style="color: #0000ff; text-decoration: underline;">《The Difference Between jQuery&rsquo;s .bind(), .live(), and .delegate()》</span></a></span></em></span>一文，觉得自己已经完全理解了.live() 和.delagate()，直到遇到了一个另一个问题，发现还是有遗漏。</p>
<p>&nbsp; &nbsp; &nbsp;先再补充下知识，简单讲讲两者之间的区别：</p>
<p>&nbsp; &nbsp; &nbsp;<span style="font-size: 16px;"><strong>.live()</strong></span></p>
<div class="cnblogs_code">
<pre>$('a').live('click', <span style="color: #0000ff;">function</span>() { alert("That tickles!") });</pre>
</div>
<p>&nbsp; &nbsp; JQuery把alert函数绑定到$(document)元素上，并使用&rsquo;click&rsquo;和&rsquo;a&rsquo;作为参数。任何时候只要有事件<strong>冒泡</strong>到document节点上，它就查看该事件是否是一个click事件，以及该事件的目标元素与&rsquo;a&rsquo;这一CSS选择器是否匹配，如果都是的话，则执行函数。</p>
<p>　　live方法还可以被绑定到具体的元素(或context)而不是document上，像这样：</p>
<div class="cnblogs_code">
<pre>$('a', $('#container')[0]).live(...);</pre>
</div>
<p>&nbsp; &nbsp; <strong><span style="font-size: 16px;">.delegate()</span></strong></p>
<div class="cnblogs_code">
<pre>$('#container').delegate('a', 'click', <span style="color: #0000ff;">function</span>() { alert("That tickles!") });</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;jQuery扫描文档查找$(&lsquo;#container&rsquo;)，并使用click事件和&rsquo;a&rsquo;这一CSS选择器作为参数把alert函数绑定到$(&lsquo;#container&rsquo;)上。任何时候只要有事件冒泡到$(&lsquo;#container&rsquo;)上，它就查看该事件是否是click事件，以及该事件的目标元素是否与CCS选择器相匹配。如果两种检查的结果都为真的话，它就执行函数。</p>
<p>　　可以注意到，<span style="color: #000000;">这一过程与.live()类似，但是其把处理程序绑定到具体的元素而非document这一根上。</span>精明的JS&rsquo;er们可能会做出这样的结论，即$('a').live() == $(document).delegate('a')，是这样吗?嗯，不，不完全是。</p>
<p>&nbsp; &nbsp; &nbsp;<span style="font-size: 16px;"><strong>为什么.delegate()要比.live()好用</strong></span></p>
<p>&nbsp; &nbsp; &nbsp;<span>基于几个原因，人们通常更愿意选用jQuery的delegate方法而不是live方法。考虑下面的例子：</span></p>
<div class="cnblogs_code">
<pre>$('a').live('click', <span style="color: #0000ff;">function</span><span style="color: #000000;">() { blah() }); 
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 或者 </span>
$(document).delegate('a', 'click', <span style="color: #0000ff;">function</span>() { blah() });</pre>
</div>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp;速度</strong></p>
<p>　　后者实际上要快过前者，因为前者首先要扫描整个的文档查找所有的$(&lsquo;a&rsquo;)元素，把它们存成jQuery对象。尽管live函数仅需要把&rsquo;a&rsquo;作为串参数传递以用做之后的判断，但是$()函数并未知道被链接的方法将会是.live().<strong><br /></strong></p>
<p>　　而另一方面，delegate方法仅需要查找并存储$(document)元素。</p>
<p>　　一种寻求避开这一问题的方法是调用在$(document).ready()之外绑定的live，这样它就会立即执行。在这种方式下，其会在DOM获得填充之前运行，因此就不会查找元素或是创建jQuery对象了。</p>
<p><strong>　　灵活性和链能力</strong></p>
<p>　　live函数也挺令人费解的。想想看，它被链到$(&lsquo;a&rsquo;)对象集上，但其实际上是在$(document)对象上发生作用。由于这个原因，它能够试图以一种吓死人的方式来把方法链到自身上。实际上，我想说的是，以$.live(&lsquo;a&rsquo;,&hellip;)这一形式作为一种全局性的jQuery方法，live方法会更具意义一些。</p>
<p><strong>　　仅支持CSS选择器</strong></p>
<p>　　最后一点，live方法有一个非常大的缺点，那就是它仅能针对直接的CSS选择器做操作，这使得它变得非常的不灵活。</p>
<p>　　欲了解更多关于CSS选择器的缺点，请参阅<span style="color: #0000ff;">《<a href="http://www.alfajango.com/blog/exploring-jquery-live-and-die/"><span style="color: #0000ff;">Exploring jQuery .live() and .die()》</span></a></span>一文。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;以上是我在网上找到的介绍.live()和.delegate()区别的资料，相信大家对此应该有了大致的了解，那我们再来看下以下的应用场景：</p>
<div class="cnblogs_code">
<pre>&lt;!DOCTYPE&gt;
&lt;html&gt;
    &lt;head&gt;
     &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;span class="cb"&gt;
          &lt;a href="./xxxxxx"&gt;相关链接&lt;/a&gt;
        &lt;/span&gt;
    &lt;/div&gt;

    &lt;script type="text/javascript"&gt;<span style="color: #000000;">
        $(</span>'.ca a').live("click", <span style="color: #0000ff;">function</span><span style="color: #000000;"> (event) {
          location.href </span>= 'ca.html'<span style="color: #000000;">;
          </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        });
        $(</span>'div').delegate(".cb a", "click", <span style="color: #0000ff;">function</span><span style="color: #000000;"> (event) {
            location.href </span>= 'cb.html'<span style="color: #000000;">;
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        });    
    </span>&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;以上代码是在一个连接中绑定了两个事件，跳转到不同的页面。（真正项目中，这种例子明显是个bug，不过在多人同时开发一个项目时，这种情况还是可能出现，每个开发者都根据id或者class来绑定事件，在不小心时会出现重叠）。ok，那大家觉得这种应用场景，当用户点击了那个连接时，是会跳转到ca.html？还是cb.html，也就是先触发live事件，还是delegate事件？</p>
<p>&nbsp; &nbsp; &nbsp;好，揭晓答案：是delegate事件，因为delegate是绑定在div上，而live是绑定在document上。当事件冒泡时，因此会先触发delegate事件。</p>
<p>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;参考文章：</p>
<p><a href="http://kb.cnblogs.com/page/94469/">http://kb.cnblogs.com/page/94469/</a></p>
<p><a href="http://www.alfajango.com/blog/the-difference-between-jquerys-bind-live-and-delegate/">http://www.alfajango.com/blog/the-difference-between-jquerys-bind-live-and-delegate/</a></p>]]></description></item><item><title>decodeURIComponent 报错</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/16/2551956.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sat, 16 Jun 2012 09:02:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/16/2551956.html</guid><description><![CDATA[<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>/searchindex?query=%CB%C9%B8%E2%BA%F1%B5%D7%C1%B9%D0%AC</pre>
</div>
<p>苏胖之前提到的问题：</p>
<p><a href="http://cnodejs.org/topic/4fd6b7ba839e1e581407aac8">http://cnodejs.org/topic/4fd6b7ba839e1e581407aac8</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>                                url =<span style="color: #000000;"> decodeURIComponent(url);
          </span>^<span style="color: #000000;">
URIError: URI malformed
    at LineReader.</span>&lt;anonymous&gt; (/home/jifeng.zjd/taobaoindex/bin/associated_query.js:34:11)
    at LineReader.emit (events.js:67:17<span style="color: #000000;">)
    at LineReader.ondata (</span>/home/jifeng.zjd/taobaoindex/node_modules/ndir/lib/ndir.js:261:8)
    at LineReader.ondata (/home/jifeng.zjd/taobaoindex/node_modules/ndir/lib/ndir.js:262:8)
    at LineReader.ondata (/home/jifeng.zjd/taobaoindex/node_modules/ndir/lib/ndir.js:262:8)
    at LineReader.ondata (/home/jifeng.zjd/taobaoindex/node_modules/ndir/lib/ndir.js:262:8)
    at LineReader.ondata (/home/jifeng.zjd/taobaoindex/node_modules/ndir/lib/ndir.js:262:8)
    at LineReader.ondata (/home/jifeng.zjd/taobaoindex/node_modules/ndir/lib/ndir.js:262:8)
    at LineReader.ondata (/home/jifeng.zjd/taobaoindex/node_modules/ndir/lib/ndir.js:262:8)
    at LineReader.ondata (/home/jifeng.zjd/taobaoindex/node_modules/ndir/lib/ndir.js:262:8)</pre>
</div>]]></description></item><item><title>nodejs测试私有变量</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/15/2550684.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Fri, 15 Jun 2012 06:50:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/15/2550684.html</guid><description><![CDATA[<p>原文：</p>
<p><a href="http://howtonode.org/testing-private-state-and-mocking-deps">http://howtonode.org/testing-private-state-and-mocking-deps</a></p>]]></description></item><item><title>mongodb batchSize</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/14/2549075.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 14 Jun 2012 03:47:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/14/2549075.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp;mongodb中batchSize参数是个相对</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>参考文章：</p>
<p><a href="http://www.mongodb.org/display/DOCS/Queries+and+Cursors#QueriesandCursors-Executionofqueriesinbatches">http://www.mongodb.org/display/DOCS/Queries+and+Cursors#QueriesandCursors-Executionofqueriesinbatches</a></p>
<p>读取多少条数据到内存</p>
<p><a href="http://neptune.iteye.com/blog/676839">http://neptune.iteye.com/blog/676839</a></p>]]></description></item><item><title>mongodb的运维</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/08/2541936.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Fri, 08 Jun 2012 08:12:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/08/2541936.html</guid><description><![CDATA[<p>&nbsp;</p>
<p>&nbsp;</p>
<p>mongodb报错：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">{ [MongoError: db assertion failure]
  name: </span>'MongoError'<span style="color: #000000;">,
  assertion: </span>'JS_NewObject failed for global'<span style="color: #000000;">,
  assertionCode: </span>10432<span style="color: #000000;">,
  errmsg: </span>'db assertion failure'<span style="color: #000000;">,
  ok: </span>0 }</pre>
</div>]]></description></item><item><title>从nodejs实战中详解HTTP协议（一）</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/07/2541000.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 07 Jun 2012 14:11:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/07/2541000.html</guid><description><![CDATA[<p>HTTP协议是每个web开发工程师每天开发时都在打交道的东西，但你真正弄懂了http的相关细节了吗？嘿嘿，还是跟着查漏补缺下吧。</p>
<p>权威参考资料：<span style="color: #0000ff;"><a href="http://www.ietf.org/rfc/rfc2616.txt"><span style="color: #0000ff;">HTTP协议</span></a></span>&nbsp;和<span style="color: #0000ff;"><a href="http://nodejs.org/api/"><span style="color: #0000ff;">nodej</span></a></span><span style="color: #0000ff;"><span>&nbsp;，</span></span></p>
<p>&nbsp;</p>
<p><strong>http的特点</strong></p>
<p><span>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</span></p>
<p>HTTP协议的主要特点可概括如下：</p>
<p><span>1.支持客户/服务器模式。</span></p>
<p><span>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</span></p>
<p><span>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</span></p>
<p><span>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</span></p>
<p><span>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</span></p>
<p style="text-align: right;">&mdash;&mdash;摘自《<a href="http://blog.csdn.net/gueter/article/details/1524447">HTTP协议详解</a>》 &nbsp; &nbsp;</p>
<p>&nbsp;补充：</p>
<p>HTTP1.0和HTTP1.1的区别：</p>
<p>HTTP1.0的主要缺点：由于它是无连接的，因此每次连接后都会断开这次连接，当下一次请求时有得再一次网络连接，这个网络消耗是比较大的，而且游览器和服务器为每次建立新的TCP连接都要分配缓存和变量。特别是服务器往往要同时服务于多个客户的请求，这样会使服务器的压力更大。</p>
<p><img src="http://pic002.cnblogs.com/images/2012/311780/2012060722295889.jpg" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>参考文章：</p>]]></description></item><item><title>cookie转小写，nodejs实现</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/07/2540280.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 07 Jun 2012 06:29:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/07/2540280.html</guid><description><![CDATA[<p>cookie转小写，nodejs实现</p>]]></description></item><item><title>nodejs异步 setTimeout()</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/05/2536393.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Tue, 05 Jun 2012 03:22:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/05/2536393.html</guid><description><![CDATA[<p>异步操作</p>
<p>&nbsp;</p>
<p>setTimeout是否异步？</p>
<p>ajax是否异步？</p>
<p>参考文章：</p>
<p><a href="http://www.infoq.com/cn/articles/nodejs-asynchronous-io">http://www.infoq.com/cn/articles/nodejs-asynchronous-io</a></p>
<p><a href="http://www.iamued.com/qianduan/1645.html">http://www.iamued.com/qianduan/1645.html</a></p>
<p><a href="http://blog.csdn.net/historyasamirror/article/details/5778378">http://blog.csdn.net/historyasamirror/article/details/5778378</a></p>]]></description></item><item><title>再谈json</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/06/01/2530933.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Fri, 01 Jun 2012 08:10:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/06/01/2530933.html</guid><description><![CDATA[<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre>  <span style="color: #0000ff;">var</span> _res =<span style="color: #000000;"> {};
  _res.render </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (view, data) {
    _res.view </span>=<span style="color: #000000;"> view;
    _res.data </span>=<span style="color: #000000;"> data;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data;
  };

  _res.setHeader </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (key, value) {
    _res.hk </span>=<span style="color: #000000;"> key;
    _res.hv </span>=<span style="color: #000000;"> value;
  };
  _res.cookie </span>= <span style="color: #0000ff;">function</span><span style="color: #000000;"> (key, value) {
    res.ck </span>=<span style="color: #000000;"> key;
    res.cv </span>=<span style="color: #000000;"> value;  
  }</span></pre>
</div>]]></description></item><item><title>那些年，在nodejs上踩过的坑（一）</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/31/2527016.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 31 May 2012 13:44:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/31/2527016.html</guid><description><![CDATA[<p>&nbsp; &nbsp; 自己写nodejs也有一段时间，踩过很多坑（而且大部分是自己给自己埋），也见过很多别人踩过的坑，原因其实也很简单，要么是对这个知识点理解不够深入，要么就是编码的习惯不好。这段响应<span style="color: #000080;"><a href="http://weibo.com/ialeafs"><span style="color: #000080;">朋春</span></a></span>大牛的号召，打算陆陆续续整理下这些坑，算是给自己一个备忘，同时也希望能对大家有所帮助。</p>
<p>&nbsp; &nbsp; <strong>1. callback</strong></p>
<p>&nbsp; &nbsp; 事件回调是nodejs非常常见的一个应用场景，那大家先来看看以下这段代码是否存在什么问题？</p>
<div class="cnblogs_code">
<pre>get(params, <span style="color: #0000ff;">function</span><span style="color: #000000;">(err, data) {
  </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (err) {
    callback(err);
  }
  </span><span style="color: #008000;">//</span><span style="color: #008000;">对data进行操作</span>
  <span style="color: #0000ff;">var</span> row = data[0<span style="color: #000000;">];
});</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp;看出来了吧。对，就是err存在时，callback之后，接下来的代码还是要执行的。而这时，data值是什么，我们往往是没办法控制的。如果data这时返回的是undefined，那么就悲剧了，程序肯定报错。当然解决方法很简单，就是在callback之前加个return即可：</p>
<div class="cnblogs_code">
<pre>get(params, <span style="color: #0000ff;">function</span><span style="color: #000000;">(err, data) {
  </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (err) {
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> callback(err);
  }
  </span><span style="color: #008000;">//</span><span style="color: #008000;">对data进行操作</span>
  <span style="color: #0000ff;">var</span> row = data[0<span style="color: #000000;">];
});</span></pre>
</div>
<p>&nbsp; &nbsp; 这个知识点并不是很难，但往往是初学者特别容易犯的错，甚至已经写了很久代码的同学也会偶尔犯这种低级错误。</p>
<p>&nbsp; &nbsp; 再来一个更隐蔽的：</p>
<div class="cnblogs_code">
<pre>db.get(key, <span style="color: #0000ff;">function</span><span style="color: #000000;">(err, data) {
  </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (err) {
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> callback(err);
  }
  </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
    callback(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">, JSON.parse(data.toString()))
  } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(e) {
    callback(e);
  }
});</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp;<span>看似没有任何问题吧。嘿嘿，揭晓答案， 对，被回调两次。callback(null, Error)一次，callback(e)，具体比如：</span></p>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> asyncfun(data, callback) {
  </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
    callback(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">, JSON.parse(data.toString()));
  } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (e) {
    callback(e);
  }
}
</span><span style="color: #0000ff;">var</span> json = {'a': 'b'<span style="color: #000000;">};
</span><span style="color: #0000ff;">var</span> jsonstr =<span style="color: #000000;"> JSON.stringify(json);
</span><span style="color: #0000ff;">var</span> d = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Buffer(jsonstr);

asyncfun(d, </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(err, data) {
  console.log(err);
  </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> Error('new Error'<span style="color: #000000;">);
});</span></pre>
</div>
<p><span>&nbsp; &nbsp; 运行结果：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">null</span><span style="color: #000000;">
[Error: </span><span style="color: #0000ff;">new</span> Error]</pre>
</div>
<p><span>&nbsp; &nbsp; &nbsp; 这在一个大项目绝对是坑爹了，排错都需要很久。</span></p>
<p><span>&nbsp;</span></p>
<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<strong>2. buffer</strong></p>
<p>&nbsp; &nbsp; &nbsp; 还是老规矩，先看代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> data = ""<span style="color: #000000;">;  
res.on(</span>'data', <span style="color: #0000ff;">function</span><span style="color: #000000;"> (chunk) {  
  data </span>+=<span style="color: #000000;"> chunk;  
})  
.on(</span>"end", <span style="color: #0000ff;">function</span><span style="color: #000000;"> () {  
  </span><span style="color: #008000;">//</span><span style="color: #008000;">对data转码  </span>
}); </pre>
</div>
<p>&nbsp; &nbsp; 这段代码在chunk都是ascii码数据或者数据量比较少时是没有问题，但如果你的数据是大量中文的话，恭喜你，中枪了，会出现乱码。其原因是两个chunk（Buffer对象）的拼接并不正常，相当于进行了buffer.toString() + buffer.toString()。如果buffer不是完整的，则toString出来后的string是存在问题的（比如一个中文字被截断）。具体可以参见<span style="color: #0000ff;"><a href="http://weibo.com/shyvo"><span style="color: #0000ff;">朴灵</span></a></span>写得这篇文章：<span style="color: #0000ff;"><a href="http://cnodejs.org/topic/4faf65852e8fb5bc65113403"><span style="color: #0000ff;">http://cnodejs.org/topic/4faf65852e8fb5bc65113403</span></a></span></p>
<p>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; 3. 深度嵌套</p>
<p>&nbsp; &nbsp; 很多刚开始写nodejs代码的人，由于思路还停留在同步的思维，所以或多或少写过这样的代码：</p>
<div class="cnblogs_code">
<pre>func1(err, <span style="color: #0000ff;">function</span><span style="color: #000000;">(err1, data1) {
  func2(err1, </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(err2, data2) {
    func3(err3, </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(err3, data3) {
      func4(err4, </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(err4, data4) {
        .......
      })
    })
  })
})</span></pre>
</div>
<p>&nbsp; &nbsp; 先别说这样的代码是否易于维护，光样子就够难看，代码都&ldquo;斜&rdquo;了。不怕大家耻笑，我自己刚开始就写时也写过这样&ldquo;坑爹&rdquo;的代码，为此自己当时还写了篇《<a class="titlelink" href="http://www.cnblogs.com/lengyuhong/archive/2011/12/22/2290711.html">如何让nodejs同步操作</a>》讲如何解决这个问题。不过从源头上，大家还是要尽量避免采用这种同步的方法，因为nodejs得优势就在于异步，硬生生要做成同步绝对吃力不讨好</p>
<p>&nbsp;</p>]]></description></item><item><title>网络请求</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/31/2528380.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 31 May 2012 06:34:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/31/2528380.html</guid><description><![CDATA[<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * get data from itier
 * return data should be a `{ d: [] }` format `Object`
 * 
 * @param {String} urlpath
 * @param {Function(err, data)} callback
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">function</span><span style="color: #000000;"> getItierData(urlpath, callback) {
  </span><span style="color: #0000ff;">var</span> tasks =<span style="color: #000000;"> requestPools[urlpath];
  </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">tasks) {
    tasks </span>=<span style="color: #000000;"> [callback];
    requestPools[urlpath] </span>=<span style="color: #000000;"> tasks;
  } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
    tasks.push(callback);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
  }
  </span><span style="color: #0000ff;">var</span> url =<span style="color: #000000;"> getDataURL(urlpath);
  </span><span style="color: #0000ff;">var</span> start = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Date();
  </span><span style="color: #0000ff;">var</span> options =<span style="color: #000000;"> {
    headers: {
      </span>'x-itier-format': 'json'<span style="color: #000000;">,
      </span>'x_itier_format': 'json'<span style="color: #000000;">
    },
    timeout: </span>20000, <span style="color: #008000;">//</span><span style="color: #008000;"> 20 seconds</span>
<span style="color: #000000;">  };
  urllib.request(url, options, </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(err, data) {
    </span><span style="color: #0000ff;">var</span> usetime = <span style="color: #0000ff;">new</span> Date() -<span style="color: #000000;"> start;
    </span><span style="color: #0000ff;">var</span> result = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (!err &amp;&amp;<span style="color: #000000;"> data) {
      </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
        result </span>=<span style="color: #000000;"> JSON.parse(data);
      } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(e) {
        err </span>=<span style="color: #000000;"> e;
      }
      </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">err) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> habse rowkey not found will return 404</span>
        <span style="color: #0000ff;">if</span> (result.c !== 200 || (result.m &amp;&amp; result.m !== 'hbase status code error: 404'<span style="color: #000000;">)) {
          err </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Error(result.m);
          err.name </span>= 'ItierError'<span style="color: #000000;">;
        }
      }
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> err happens </span>
    <span style="color: #0000ff;">if</span><span style="color: #000000;"> (err) {
      err.url </span>=<span style="color: #000000;"> url;
      err.usetime </span>=<span style="color: #000000;"> usetime;
      </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (Buffer.isBuffer(data)) {
        data </span>=<span style="color: #000000;"> data.toString();
      }
      </span><span style="color: #0000ff;">if</span> (data &amp;&amp; data.length &gt; 2000<span style="color: #000000;">) {
        data </span>= data.substring(0, 2000) + ' [...]'<span style="color: #000000;">;
      }
      err.data </span>=<span style="color: #000000;"> data;
      result </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
      </span><span style="color: #008000;">//</span><span style="color: #008000;"> make sure result =&gt; { d: [] } format</span>
      result = result ||<span style="color: #000000;"> {};
      result.d </span>= result.d ||<span style="color: #000000;"> [];
      result.usetime </span>=<span style="color: #000000;"> usetime;
      result.url </span>=<span style="color: #000000;"> url;
    }
    </span><span style="color: #0000ff;">if</span> (tasks.length === 1<span style="color: #000000;">) {
      tasks[</span>0<span style="color: #000000;">](err, result);
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
      </span><span style="color: #0000ff;">var</span> resultJSON =<span style="color: #000000;"> JSON.stringify(result);
      tasks.forEach(</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(cb, index) {
        </span><span style="color: #0000ff;">if</span> (index === 0<span style="color: #000000;">) {
          cb(err, result);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
          cb(err, JSON.parse(resultJSON));
        }
      });
    }
    </span><span style="color: #0000ff;">delete</span><span style="color: #000000;"> requestPools[urlpath];
  });
}
exports.getItierData </span>= getItierData;</pre>
</div>]]></description></item><item><title>网络相关知识</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/30/2527019.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Wed, 30 May 2012 14:03:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/30/2527019.html</guid><description><![CDATA[<p>IPv4</p>
<p>单播，广播，组播</p>
<p>&nbsp;</p>
<p>网络的设置往往是门电路，硬件写死。</p>
<p>&nbsp;</p>
<p>二层交换设备？</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>再谈javascript作用域链</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/28/2522570.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 28 May 2012 14:27:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/28/2522570.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp;自己之前写过一篇文章<span style="color: #0000ff;"><a href="http://www.cnblogs.com/lengyuhong/archive/2012/01/08/2316234.html"><span style="color: #0000ff;">《&lt;javascript高级程序设计&gt;读书笔记&mdash;&mdash;作用域》</span></a></span>&nbsp;讲作用域链的问题，但当时自己也是javascript刚入门，理解也不不深，&nbsp;更多是读书笔记的形式。最近又花了些时间来研究这个问题。</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>分布式系统缓存设计浅析</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/26/2507498.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sat, 26 May 2012 11:03:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/26/2507498.html</guid><description><![CDATA[<p>&nbsp; &nbsp; 前几天听了部门内<a href="http://weibo.com/ialeafs">朋春</a>大牛讲分布式缓存的一个技术分享，还是非常有收获。</p>
<p>　　PPT如下：</p>
<p style="text-align: center;"><iframe src="http://www.slideshare.net/slideshow/embed_code/12977939" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" width="500" height="417"></iframe></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; 这个分享的副标题是&ldquo;简单的事情从来不简单&rdquo;，这句话讲得非常在理。缓存看似简单，但要做&ldquo;好&rdquo;一个缓存系统也是很有讲究的。 &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; 写点自己的心得收获吧：</p>
<p>&nbsp; &nbsp; <span style="font-size: 14pt;"><strong>1. 分布式缓存面临比较大的三个问题：</strong></span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<strong>（1） 数据一致性。</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;在分布式系统这点显得尤为重要，主要原因有三点：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;缓存系统与底层数据的一致性。这点在底层系统是&ldquo;可读可写&rdquo;时，写得尤为重要</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;有继承关系的缓存之间的一致性。为了尽量提高缓存命中率，缓存也是分层：全局缓存，二级缓存。他们是存在继承关系的。全局缓存可以有二级缓存来组成。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;多个缓存副本之间的一致性。为了保证系统的高可用性，缓存系统背后往往会接两套存储系统（如memcache，redis等），以上的ppt也主要是讲这方面的内容。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<strong>（2）缓存雪崩</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;当缓存系统重启或者所有缓存在同一时刻失效（比如某些系统为了提高速度，会在系统启动是统一将大部分数据刷到缓存中，此时如果设置缓存时间都是24小时，那24小时过后，那就悲剧）时，应用系统由于扛不住压力而直接挂掉。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<strong>（3）缓存穿透</strong></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;查询一个必然不存在的数据，查询一个必然不存在的key，每次都会访问DB，如果有人恶意破坏，那么很可能直接对DB造成影响。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 第一点偏重数据的真实性和实时性，而第二点和第三点更多从性能上考虑。同时缓存并不一定是必需的，特别是当写操作特别频繁时。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;<span style="font-size: 14pt;"><strong>2. 缓存数据的淘汰</strong></span></p>
<p>&nbsp; &nbsp; &nbsp;原先缓存数据的淘汰往往是用设置缓存时间，比如我设置某个数据的缓存时间是24小时，之后的24内这个缓存是不会失效的。优点当然是简单，缺点也很明显就是不都灵活，没做到好的精细化管理。</p>
<p>&nbsp; &nbsp; 我们能利用的资源就是：1. 给缓存加tag，2. 版本号（必须单调递增，时间戳是最好的选择）3. 提供手动清理缓存的接口。</p>
<p>&nbsp; &nbsp; 相关步骤可以参见以上的PPT内容。</p>
<p>&nbsp; &nbsp; 缓存相关接口：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> me =<span style="color: #000000;"> Cache.create(...);
me.set(key, value, ttl, tags);
me.get(key);
me.tagrm(tag, offset, flush);</span></pre>
</div>
<p>&nbsp; &nbsp; 缓存的数据结构如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> data =<span style="color: #000000;"> {
  &lsquo;i&rsquo;:now, </span><span style="color: #008000;">/*</span><span style="color: #008000;">* 数据写入时间戳 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
  &lsquo;e&rsquo;:now </span>+ ttl,<span style="color: #008000;">/*</span><span style="color: #008000;">* 预期过期时间 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
  &lsquo;k&rsquo;:key, </span><span style="color: #008000;">/*</span><span style="color: #008000;">* 原始key </span><span style="color: #008000;">*/</span><span style="color: #000000;">
  &lsquo;v&rsquo;:value, </span><span style="color: #008000;">/*</span><span style="color: #008000;">* 原始值 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
  &lsquo;t&rsquo;:tags </span><span style="color: #008000;">/*</span><span style="color: #008000;">* tag列表 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
};</span></pre>
</div>
<p>&nbsp; &nbsp; 我刚开始的也没弄明白为什么在data中还要存&ldquo;原始的key&rdquo;，后来经朋春提醒，才弄明白：原始的key可能过长或者存在特殊字符时，是不能直接作为某些系统的key，因此往往会对原始key做一次hash来作为缓存的新key。</p>
<p>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; <strong><span style="font-size: 14pt;">3. 缓存淘汰的策略</span></strong></p>
<p>&nbsp; &nbsp; 缓存淘汰的策略有两种：</p>
<p>&nbsp; &nbsp; (1) 定时去清理过期的缓存。</p>
<p>&nbsp; &nbsp;（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p>
<p>&nbsp; &nbsp; 两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>异步加载</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/25/2518663.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Fri, 25 May 2012 13:54:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/25/2518663.html</guid><description><![CDATA[<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> loadScript(url){
  </span><span style="color: #0000ff;">var</span> ga = document.createElement('script'<span style="color: #000000;">);
  ga.type </span>= 'text/javascript'<span style="color: #000000;">; 
  ga.async </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
  ga.src </span>=<span style="color: #000000;"> url;
  (document.getElementsByTagName(</span>'head')[0] || document.getElementsByTagName('body')[0<span style="color: #000000;">]).appendChild(ga); 
}
</span><span style="color: #008000;">//</span><span style="color: #008000;">loadScript(uaurl);</span></pre>
</div>]]></description></item><item><title>浏览器中javascript的执行过程</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/20/2509120.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 20 May 2012 10:28:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/20/2509120.html</guid><description><![CDATA[<p>&nbsp; &nbsp; 在讲这个问题之前，先来补充几个知识点，如果对此已经比较了解可以直接跳过</p>
<p>&nbsp; &nbsp; 1. 大多数浏览器的组件构成如图</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="http://pic002.cnblogs.com/images/2012/311780/2012052015072072.png" alt="" /></p>
<p>&nbsp; &nbsp; 在最底层的三个组件分别是网络，UI后端和js解释器。作用如下：</p>
<p>&nbsp; &nbsp; （1）网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</p>
<p>&nbsp; &nbsp; （2）UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</p>
<p>&nbsp; &nbsp; （3）JS解释器－ 用来解释执行JS代码</p>
<p>&nbsp;ps：上图和知识点主要来自《<span style="color: #0000ff;"><a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/"><span style="color: #0000ff;">HOW BROWSERS WORK: BEHIND THE SCENES OF MODERN WEB BROWSERS</span></a></span>》 想深入了解的同学可以重点看下。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 2. 大多数浏览器（比如chrome）让一个单线程共用于执行javascrip和更新用户界面。这个线程通常被称为&ldquo;浏览器UI线程&rdquo;， 每个时刻只能执行其中一种操作，这意味着当Javascript代码正在执行时用户界面无法响应输入，反之亦然。这样做是因为javascript代码的作用就是操作DOM更新用户界面，用同一个线程来做负责这两件事情可以更高效</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 3. 浏览器UI线程的工作基于一个简单的队列系统，任务会被保存到队列中直到进程空闲。一旦空闲，队列中的下一个任务就被重新提取出来并运行。这些任务要么是运行javascript代码，要么执行UI更新，包括重绘和重排。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 4. 重点再强调下，javascript是单线程运行，千万别被setTimeout()和setInterVal()这种函数迷惑而误以为它是多线程。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;ok，基础点讲解完毕，让我们进入正题，来讲解在浏览器中javascript的执行过程。</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;<span style="font-size: 16px;"><strong>一、原理</strong></span></p>
<p>&nbsp; &nbsp; &nbsp;一般而言，&lt;script&gt;标签每次出现都会霸道地让页面等待脚本的解析和执行，无论当前的Javascript是内嵌的还是包含了外链文件，页面的下载和渲染都必须停下来等待脚本执行完成。这在页面的生存周期中是必要的，因为脚本执行过程中可能修改页面内容，一个典型的例子就是在页面中使用document.write()。</p>
<p>&nbsp; &nbsp; &nbsp;当javascript代码是内嵌在html里面时，这点还是比较容易理解，但当javascript是外链文件时稍微有点负载，因为存在一个加载过程，而且浏览器加载好这个js文件之后往往还对其缓存。</p>
<p>&nbsp; &nbsp; &nbsp;首先，我们用以下这个例子来说明下缓存问题</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span> 
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">='text/javascript' </span><span style="color: #ff0000;">src</span><span style="color: #0000ff;">='js/f2.js'</span><span style="color: #0000ff;">&gt;&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span> </pre>
</div>
<p>&nbsp; &nbsp; &nbsp;第一次打开页面时：</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="http://pic002.cnblogs.com/images/2012/311780/2012052016310016.jpg" alt="" /></p>
<p>&nbsp; &nbsp; 第二次打开页面时：</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="http://pic002.cnblogs.com/images/2012/311780/2012052016342351.jpg" alt="" /></p>
<p>&nbsp; &nbsp; 从上例中可以明显看出，像chrome之类的高版本浏览器会对js文件进行缓存，作用是不言而喻，减少网络请求。</p>
<p>&nbsp;</p>
<p>　 其次，第二个问题，当一个javascript文件被加载时是否会阻塞其他javascript文件或者其他文件的加载。《高性能Javascript》一书中对这个问题做了较好的解答：各种浏览器的低版本的处理是当一个javascript文件在加载时，会同时阻塞页面其他文件的加载（包括其他javascript文件），但IE8，Firfox3.5，Safari 4和Chrome 2都允许并行下载javascript文件，但遗憾的是，javascript下载过程仍然会组舍其他资源的下载，比如图片。尽管javascript脚本的下载过程不会相互影响，但页面仍然必须等待所有的javascript代码下载并执行完成才能继续。</p>
<p>&nbsp; &nbsp; &nbsp;这里说句题外话：浏览器对同一域名下的并发链接数也是有限制的，其他一些参数如下：</p>
<p>&nbsp; &nbsp;<img src="http://pic002.cnblogs.com/images/2012/311780/2012052017005537.jpg" alt="" /></p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;<strong><span style="font-size: 16px;">二、技巧</span></strong></p>
<p>&nbsp; &nbsp; &nbsp;1. 脚本位置</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;由于脚本会阻塞页面其他资源的下载，因此推荐将所有的&lt;script&gt;标签放到&lt;body&gt;标签的底部，已尽量减少对整个页面下载的影响。</p>
<p>&nbsp; &nbsp; &nbsp;2. 将能合并的js文件合并</p>
<p>&nbsp; &nbsp; &nbsp;3. 无阻塞脚本</p>
<p>&nbsp; &nbsp; &nbsp;现在比较常用的方法就是动态加载执行脚本。你的原理是通过DOM，你几乎可以用Javascript动态创建HTML中的所有内容，其根本在于，&lt;script&gt;标签与页面中其他元素并无差异：都能通过DOM引用，都能在文档中移动，删除和创建。文件在改该&lt;script&gt;元素被添加到页面时开始现在，它不会阻止其他文件下载，只在执行阶段阻塞渲染。特别强调：《高性能javascript》一文中说&ldquo;这种技术的重点在于：无论何时启动下载，文件的下载和执行都不会阻塞页面其他进程&rdquo;，这并不是说它在执行不会阻塞其他javascript代码，而是要强调不会阻塞其他资源的下载等其他任务。</p>
<p>&nbsp; &nbsp; &nbsp;具体的代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span><span style="color: #000000;"> loadScript(url){
  </span><span style="color: #0000ff;">var</span> ga = document.createElement('script'<span style="color: #000000;">);
  ga.type </span>= 'text/javascript'<span style="color: #000000;">; 
  ga.async </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
  ga.src </span>=<span style="color: #000000;"> url;
  (document.getElementsByTagName(</span>'head')[0] || document.getElementsByTagName('body')[0<span style="color: #000000;">]).appendChild(ga); 
}</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp;4. 神奇的setTimeout（）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;这里我不过多的将setTimeout()的原理，有兴趣的读者可以具体去看《高性能javascript》的第六章。我重点强调下，setTimeout的第二个参数并不是一个精确的时间，二是必须在javascript线程空闲时才能运行。利用这个特性，如下代码简单可以实现等待其他js代码执行完毕后再执行function里面的代码。</p>
<div class="cnblogs_code">
<pre>setTimeout(<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
  </span><span style="color: #008000;">//</span><span style="color: #008000;"> do some before other javascripe codes had processed</span>
}, 25)</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 但在function里面不要使用document.write()方法，因为执行setTimeout里面函数时往往已经到了页面onload之后，此时再执行&nbsp;document.write 将导致当前页面的内容被清空，因为它会自动触发&nbsp;document.open 方法。</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>参考文章：</p>
<p><a href="http://book.douban.com/subject/5362856/">《高性能Javascript》</a></p>
<p><a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">HOW BROWSERS WORK: BEHIND THE SCENES OF MODERN WEB BROWSERS</a></p>
<p><a href="http://www.ha97.com/2908.html">Google Chrome源码剖析【一】：多线程模型</a></p>
<p><a href="http://www.cnblogs.com/tiwlin/archive/2011/12/26/2302554.html">javascript异步加载详解</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;&nbsp;</p>]]></description></item><item><title>CSRF攻击原理以及nodejs的实现和防御</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/16/2486420.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Wed, 16 May 2012 14:17:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/16/2486420.html</guid><description><![CDATA[<p>&nbsp; &nbsp; <strong><span style="font-size: 16px;">一、简介</span></strong></p>
<p>&nbsp; &nbsp; CSRF (Cross-site Request Forgery)，中文名称：跨站伪造。危害是攻击者可以盗用你的身份，以你的名义发送恶意请求。比如可以盗取你的账号，以你的身份发送邮件，购买商品等。</p>
<p>&nbsp; &nbsp; <strong><span style="font-size: 16px;">二、原理</span></strong></p>
<p>&nbsp; &nbsp; 具体的原理图如下：</p>
<p>&nbsp; &nbsp;<img style="display: block; margin-left: auto; margin-right: auto;" src="http://pic002.cnblogs.com/images/2012/311780/2012050618354859.jpg" alt="" data-markzhi="registered" /></p>
<p>&nbsp; &nbsp; 更加恐怖的是使用诸如img之类的标签，甚至不需要用户点击某个链接就可以发起攻击，比如B网站可以添加如下代码：</p>
<div class="cnblogs_code">
<pre>    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">img </span><span style="color: #ff0000;">src</span><span style="color: #0000ff;">='http://www.company.com/action?k1=v1&amp;k2=v2' </span><span style="color: #ff0000;">width</span><span style="color: #0000ff;">=0 </span><span style="color: #ff0000;">height</span><span style="color: #0000ff;">=0 </span><span style="color: #0000ff;">/&gt;</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 这里width=0 height=0&nbsp;表示图片是不可见的。这个语句会导致游览器向另外的服务器发送一个请求。游览器不管该图片url实际是否指向一张图片，只要src字段中规定了url，就会按照地址触发这个请求。（游览器默认都是没有禁止下载图片，这是因为禁用图片后大多数web程序的可用性就会打折扣）。加载图片根本不考虑所涉及的图像所在位置（可以跨域）。如果A网站不小心提供了get接口就非常不幸得中招了</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong><span style="font-size: 16px;">三、攻击</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; <span style="color: #0000ff;">《<a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html"><span style="color: #0000ff;">浅谈CSRF攻击方式</span></a>》</span>一文中已经用实例讲解了一个php的实现和防御方法，我这里主要是讲nodejs的实现和防御。为了简单起见，假设我们有一个应用，它提供了两个接口&ldquo;/get/checkvalue&rdquo;和 &ldquo;'/post/setvalue&rdquo;，它们都接受一个参数&ldquo;value&rdquo;来改变系统的一个某个值。 当然前提是用户已经正常登陆了。具体逻辑是它有一个用户登陆的过程，登陆成功后会将用户信息存到cookie中，之后就根据cookie来判断是否能正常访问，当然cookie信息经过md5加密。（真实应用中千万不要这么做，md5加密并不是非常安全）。</p>
<p>&nbsp; &nbsp; &nbsp; 服务主程序：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> app =<span style="color: #000000;"> http.createServer(function(req, res) {
  </span><span style="color: #008000;">//</span><span style="color: #008000;">权限判断</span>
<span style="color: #000000;">  authMiddle(req, res, function(err, checkValue){
    </span><span style="color: #0000ff;">if</span> (!checkValue) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res.end(html_login);
    </span><span style="color: #008000;">//</span><span style="color: #008000;">数据查询和操作</span>
<span style="color: #000000;">    controller(req, res);  
  });
});</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 用户权限判断逻辑：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var cookieValue = crypto.createHash('md5').update('jifeng_jifeng').digest('hex');<br />function</span><span style="color: #000000;"> getCookie(headers){
  </span><span style="color: #0000ff;">var</span> cookies =<span style="color: #000000;"> {};
  headers.cookie </span>&amp;&amp; headers.cookie.split(';').forEach(<span style="color: #0000ff;">function</span><span style="color: #000000;">(cookie) {
    </span><span style="color: #0000ff;">var</span> parts = cookie.split('='<span style="color: #000000;">);
    cookies[ parts[ </span>0 ].trim() ] = ( parts[ 1 ] || ''<span style="color: #000000;"> ).trim();
  });  
  </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cookies;
}

</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> checkUser(req, res, callback){
  </span><span style="color: #0000ff;">var</span> chunks =<span style="color: #000000;"> [];
  </span><span style="color: #0000ff;">var</span> length = 0<span style="color: #000000;">;
  </span><span style="color: #0000ff;">var</span> rows = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
  req.on(</span>'data', <span style="color: #0000ff;">function</span><span style="color: #000000;">(data){
    chunks.push(data);
    length </span>+=<span style="color: #000000;"> data.length;
  }) 
  req.on(</span>'end', <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
    </span><span style="color: #0000ff;">var</span> rows = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Buffer(length);
    </span><span style="color: #0000ff;">var</span> len = 0<span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = 0, il = chunks.length; i &lt; il; i++<span style="color: #000000;">) {
      chunks[i].copy(rows, len);
      len </span>+=<span style="color: #000000;"> chunks[i].length;
    }
    </span><span style="color: #0000ff;">var</span> args =<span style="color: #000000;"> querystring.parse(rows.toString());
    </span><span style="color: #0000ff;">if</span> (args &amp;&amp; args.name === 'jifeng' &amp;&amp; args.password ==='jifeng'<span style="color: #000000;">) {
      res.setHeader(</span>'Set-Cookie', ['cookie1987=' +<span style="color: #000000;"> cookieValue]);
      callback(</span><span style="color: #0000ff;">null</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">);   
    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
      callback(</span><span style="color: #0000ff;">null</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
    }
  }) 
}
</span><span style="color: #0000ff;">function</span><span style="color: #000000;"> authMiddle(req, res, callback){
  </span><span style="color: #0000ff;">var</span> flag = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
  </span><span style="color: #0000ff;">var</span> params = urllib.parse(req.url, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
  </span><span style="color: #0000ff;">if</span> (params.pathname === '/checkuser'<span style="color: #000000;">) {
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> checkUser(req, res, callback);    
  } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
    </span><span style="color: #0000ff;">var</span> headers =<span style="color: #000000;"> req.headers;
    </span><span style="color: #0000ff;">var</span> cookies = getCookie(headers);<span style="color: #008000;">//</span><span style="color: #008000;">得到用户cookie</span>
    <span style="color: #0000ff;">if</span> (cookies &amp;&amp;<span style="color: #000000;"> cookies.cookie1987) {
      </span><span style="color: #0000ff;">var</span> v =<span style="color: #000000;"> cookies.cookie1987;
      </span><span style="color: #0000ff;">if</span> (v ==<span style="color: #000000;"> cookieValue) {
        flag </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;  
      }
    }
    callback(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">, flag)
  }
}</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 那具体怎样进攻呢？</p>
<p>&nbsp; &nbsp; &nbsp; get攻击的页面很简单。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">img </span><span style="color: #ff0000;">src</span><span style="color: #0000ff;">='http://test3.data.taobao.com:5678/get/check?func=get&amp;value=10'</span><span style="color: #0000ff;">&gt;</span> </pre>
</div>
<p>&nbsp; &nbsp; &nbsp; post攻击的页面相对比较复杂</p>
<div class="cnblogs_code">
<pre>  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>post 测试页面<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span>
      <span style="background-color: #f5f5f5; color: #0000ff;">function</span><span style="background-color: #f5f5f5; color: #000000;"> steal(){
        </span><span style="background-color: #f5f5f5; color: #0000ff;">var</span><span style="background-color: #f5f5f5; color: #000000;"> mySubmit </span><span style="background-color: #f5f5f5; color: #000000;">=</span><span style="background-color: #f5f5f5; color: #000000;"> document.getElementById(</span><span style="background-color: #f5f5f5; color: #000000;">'</span><span style="background-color: #f5f5f5; color: #000000;">steal_form</span><span style="background-color: #f5f5f5; color: #000000;">'</span><span style="background-color: #f5f5f5; color: #000000;">);
        mySubmit.submit();
      }
    </span><span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">script</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">body </span><span style="color: #ff0000;">onload</span><span style="color: #0000ff;">='steal()'</span><span style="color: #0000ff;">&gt;</span>
　　<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">form </span><span style="color: #ff0000;">id </span><span style="color: #0000ff;">= "steal_form"</span><span style="color: #ff0000;"> method</span><span style="color: #0000ff;">="POST"</span><span style="color: #ff0000;"> action</span><span style="color: #0000ff;">="http://test3.data.taobao.com:5678/post/check"</span><span style="color: #0000ff;">&gt;</span>
　　  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">input </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="hidden"</span><span style="color: #ff0000;"> name</span><span style="color: #0000ff;">="func"</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">="post"</span><span style="color: #0000ff;">&gt;</span>
　　　<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">input </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="hidden"</span><span style="color: #ff0000;"> name</span><span style="color: #0000ff;">="value"</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">="1000"</span><span style="color: #0000ff;">&gt;</span>
　　<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">form</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp;但这里强调一点：现在游览器（chrome，firfox）为了安全考虑，默认都做了一定的限制，form标签发送到其他网站的请求会被拦截，大家有兴趣模拟这种情况时需要注意这个问题。</p>
<p>&nbsp; &nbsp; &nbsp;详细的代码：<span style="color: #0000ff;"><a href="https://github.com/jifeng/toycode/tree/master/csrf"><span style="color: #0000ff;">https://github.com/jifeng/toycode/tree/master/csrf</span></a></span></p>
<p>&nbsp; &nbsp; &nbsp;<strong><span style="font-size: 16px;">四、防范</span></strong></p>
<p>&nbsp; &nbsp; &nbsp;访问csrf的措施虽然很多，但归根到底就是一条：在客户端提交请求时增加伪造随机数。</p>
<p>&nbsp; &nbsp; &nbsp;nodejs中有些框架已经帮我们做了这件事，比如重用的<span style="color: #0000ff;"><a href="https://github.com/senchalabs/connect"><span style="color: #0000ff;">connect</span></a></span></p>
<p>　 &nbsp;它具体的实现：</p>
<p>&nbsp; &nbsp; &nbsp;<span style="color: #0000ff;"><a href="http://www.senchalabs.org/connect/csrf.html"><span style="color: #0000ff;">http://www.senchalabs.org/connect/csrf.html</span></a>&nbsp;</span> &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;举例：</p>
<p><span style="color: #0000ff;"><span style="color: #0000ff;">&nbsp; &nbsp; &nbsp;</span><a href="https://github.com/senchalabs/connect/blob/master/examples/csrf.js"><span style="color: #0000ff;">https://github.com/senchalabs/connect/blob/master/examples/csrf.js</span></a></span></p>
<p>&nbsp; &nbsp; 实现还是相对比较简单，有兴趣的同学可以再仔细看下。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>参考文章：</p>
<p><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">浅谈CSRF攻击方式</a></p>]]></description></item><item><title>跨域那些事儿</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/15/2501621.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Tue, 15 May 2012 07:08:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/15/2501621.html</guid><description><![CDATA[<p>跨域</p>]]></description></item><item><title>加载非阻塞脚本</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/14/2499734.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 14 May 2012 10:03:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/14/2499734.html</guid><description><![CDATA[<p>加载非阻塞脚本</p>]]></description></item><item><title>深入学习javascript中setTimeout方法</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/09/2493366.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Wed, 09 May 2012 14:00:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/09/2493366.html</guid><description><![CDATA[<p>&nbsp; &nbsp; setTimeout()是javascript中很常用的一个方法，它能够创建一个定时器，接受的两个参数分别是要执行的函数和执行前的等待时间（单位毫秒）。</p>]]></description></item><item><title>jquery入门——表单提交</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/09/2491315.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Wed, 09 May 2012 02:31:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/09/2491315.html</guid><description><![CDATA[<p>&nbsp; &nbsp; 在web服务中表达提交是非常常见的一种，最简单的情况如下。</p>
<p>&nbsp; &nbsp;&nbsp;</p>]]></description></item><item><title>nodejs的get和post服务</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/05/07/2488886.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 07 May 2012 13:37:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/05/07/2488886.html</guid><description><![CDATA[<p>&nbsp; &nbsp; 在web服务中，提交表达和数据时，get和post是非常常用的两种服务。现用nodejs实现这两个服务。</p>
<p>一、get操作</p>
<p>app.html：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>登陆页面<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">form </span><span style="color: #ff0000;">action</span><span style="color: #0000ff;">="check"</span><span style="color: #ff0000;"> method</span><span style="color: #0000ff;">="get"</span><span style="color: #0000ff;">&gt;</span>
      <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">p</span><span style="color: #0000ff;">&gt;</span>First name: <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">input </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="text"</span><span style="color: #ff0000;"> name</span><span style="color: #0000ff;">="fname"</span> <span style="color: #0000ff;">/&gt;&lt;/</span><span style="color: #800000;">p</span><span style="color: #0000ff;">&gt;</span>
      <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">p</span><span style="color: #0000ff;">&gt;</span>Last name: <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">input </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="text"</span><span style="color: #ff0000;"> name</span><span style="color: #0000ff;">="lname"</span> <span style="color: #0000ff;">/&gt;&lt;/</span><span style="color: #800000;">p</span><span style="color: #0000ff;">&gt;</span>
      <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">input </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="submit"</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">="Submit"</span> <span style="color: #0000ff;">/&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">form</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span> </pre>
</div>
<p>&nbsp;</p>
<p>app.js</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> http = require('http'<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> urllib = require('url'<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> fs = require('fs'<span style="color: #000000;">);

</span><span style="color: #0000ff;">var</span> html = fs.readFileSync('./app.html'<span style="color: #000000;">);

</span><span style="color: #0000ff;">var</span> app = http.createServer(<span style="color: #0000ff;">function</span><span style="color: #000000;">(req, res){
  </span><span style="color: #0000ff;">var</span> params = urllib.parse(req.url, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
  </span><span style="color: #0000ff;">if</span> (params.pathname === '/login'<span style="color: #000000;">) {
    res.end(html);
  } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (params.pathname === '/check'<span style="color: #000000;">) {
    </span><span style="color: #0000ff;">var</span> params = urllib.parse(req.url, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
    res.end(JSON.stringify(params.query));
  }
});

app.listen(</span>5678, <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
  console.log(</span>'server is listening on 5678'<span style="color: #000000;">);  
});</span></pre>
</div>
<p>&nbsp;</p>
<p>二、post操作</p>
<p>post的实现相对比较繁琐，<span style="color: #ff0000;">可以特别注意下buffer.copy这个函数</span>。</p>
<p>app.html：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>登陆页面<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">title</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">head</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">form </span><span style="color: #ff0000;">action</span><span style="color: #0000ff;">="check"</span><span style="color: #ff0000;"> method</span><span style="color: #0000ff;">="post"</span><span style="color: #0000ff;">&gt;</span>
      <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">p</span><span style="color: #0000ff;">&gt;</span>First name: <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">input </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="text"</span><span style="color: #ff0000;"> name</span><span style="color: #0000ff;">="fname"</span> <span style="color: #0000ff;">/&gt;&lt;/</span><span style="color: #800000;">p</span><span style="color: #0000ff;">&gt;</span>
      <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">p</span><span style="color: #0000ff;">&gt;</span>Last name: <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">input </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="text"</span><span style="color: #ff0000;"> name</span><span style="color: #0000ff;">="lname"</span> <span style="color: #0000ff;">/&gt;&lt;/</span><span style="color: #800000;">p</span><span style="color: #0000ff;">&gt;</span>
      <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">input </span><span style="color: #ff0000;">type</span><span style="color: #0000ff;">="submit"</span><span style="color: #ff0000;"> value</span><span style="color: #0000ff;">="Submit"</span> <span style="color: #0000ff;">/&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">form</span><span style="color: #0000ff;">&gt;</span>
  <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">body</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">html</span><span style="color: #0000ff;">&gt;</span> </pre>
</div>
<p>app.js：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> http = require('http'<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> urllib = require('url'<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> fs = require('fs'<span style="color: #000000;">);
</span><span style="color: #0000ff;">var</span> querystring = require('querystring'<span style="color: #000000;">);

</span><span style="color: #0000ff;">var</span> html = fs.readFileSync('./app.html'<span style="color: #000000;">);

</span><span style="color: #0000ff;">var</span> app = http.createServer(<span style="color: #0000ff;">function</span><span style="color: #000000;">(req, res){
  </span><span style="color: #0000ff;">var</span> params = urllib.parse(req.url, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
  </span><span style="color: #0000ff;">if</span> (params.pathname === '/login'<span style="color: #000000;">) {
    res.end(html);
  } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (params.pathname === '/check'<span style="color: #000000;">) {
    </span><span style="color: #0000ff;">var</span> chunks =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">var</span> length = 0<span style="color: #000000;">;
    </span><span style="color: #0000ff;">var</span> rows = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    req.on(</span>'data', <span style="color: #0000ff;">function</span><span style="color: #000000;">(data){
      chunks.push(data);
      length </span>+=<span style="color: #000000;"> data.length;
    }) 
    req.on(</span>'end', <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
      </span><span style="color: #0000ff;">var</span> rows = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Buffer(length);
      </span><span style="color: #0000ff;">var</span> len = 0<span style="color: #000000;">;
      </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = 0, il = chunks.length; i &lt; il; i++<span style="color: #000000;">) {
        chunks[i].copy(rows, len);
        len </span>+=<span style="color: #000000;"> chunks[i].length;
      }
      </span><span style="color: #0000ff;">var</span> args =<span style="color: #000000;"> querystring.parse(rows.toString());
      res.end(JSON.stringify(args));
    })
  }
  
});

app.listen(</span>5678, <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
  console.log(</span>'server is listening on 5678'<span style="color: #000000;">);  
});</span></pre>
</div>]]></description></item><item><title>mongodb的join操作</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/04/14/2446442.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sat, 14 Apr 2012 07:38:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/04/14/2446442.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp;众所周知，mongodb是不支持join操作的，因此我们只能自己来实现这个功能。前段时间，我遇到这个一个业务场景：</p>
<p>&nbsp; &nbsp; &nbsp;collection A 的数据格式：</p>
<div class="cnblogs_code">
<pre>{ "_id" : { "username" : "jifeng.zjd", "version" : 2 }, "value" : 1 }</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;collection B 的数据格式：</p>
<div class="cnblogs_code">
<pre>{ "user_id" : 12630, "username" : "jifeng.zjd" }</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;A表的数据量为2w，B表的数据量为25w。为了说明简单，我简化下需求，就是计算A._id.username = B.username 的B表中的用户数据，也就是求A和B的交集。没有join，怎么办呢？</p>
<p>&nbsp; &nbsp; &nbsp;相信大家都应该有自己的解答了，由于A表的数据量相对于B表来讲是少的，所以可以先取出A表的所有数据，然后去B表查询，看那些数据同时存在于A和B表中。当然在mongodb中对A和B建立适当的索引是非常必要的。我采用的方法是对B表的username字段进行索引。如对mongodb索引不了解，可以参见<span style="color: #0000ff;"><span style="color: #0000ff;"><a href="http://blog.nosqlfan.com/html/758.html"><span style="color: #0000ff;">《mongoDB的索引使用及索引机制》</span></a>&nbsp;<span style="color: #000000;">一文。</span></span></span></p>
<p><span style="color: #0000ff;"><span style="color: #0000ff;"><span style="color: #000000;">&nbsp; &nbsp; &nbsp;这里我使用的语言是nodejs，node_module采用的mongoskin，我刚开始写了一个简单的实现：</span></span></span></p>
<div class="cnblogs_code">
<pre>db.A.find({}, {}, <span style="color: #0000ff;">function</span><span style="color: #000000;">(err, adata){
  </span><span style="color: #0000ff;">if</span> (err) <span style="color: #0000ff;">return</span><span style="color: #000000;"> callback(err);
  </span><span style="color: #008000;">//</span><span style="color: #008000;">得到A表中的所有数据</span>
  adata.toArray(<span style="color: #0000ff;">function</span><span style="color: #000000;">(err, aArray){
    </span><span style="color: #0000ff;">if</span> (err) <span style="color: #0000ff;">return</span><span style="color: #000000;"> callback(err);
    </span><span style="color: #0000ff;">var</span> len =<span style="color: #000000;"> aArray.length;
    </span><span style="color: #0000ff;">var</span> result =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = 0; i &lt; len; i++<span style="color: #000000;">) {
      </span><span style="color: #0000ff;">var</span> item =<span style="color: #000000;"> aArray[i];
      </span><span style="color: #0000ff;">var</span> username =<span style="color: #000000;"> item._id.username;
      </span><span style="color: #0000ff;">var</span> op =<span style="color: #000000;"> {username: username};
      </span><span style="color: #008000;">//</span><span style="color: #008000;">查看B表中这条数据</span>
      db.B.findOne(op, {}, <span style="color: #0000ff;">function</span><span style="color: #000000;">(err, data){
        allcount</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (data) {
          result.push(data.username); 
        }
        </span><span style="color: #0000ff;">if</span> (allcount ===<span style="color: #000000;"> len) {
          callback(</span><span style="color: #0000ff;">null</span><span style="color: #000000;">, result); 
        } 
      })
    }
  })
})</span></pre>
</div>
<p><span style="color: #0000ff;"><span style="color: #0000ff;"><span style="color: #000000;">&nbsp; &nbsp; &nbsp; 这段代码是能满足业务需求，但大家有没有发现它存在一个致命的问题？对，运行速度慢！</span></span></span></p>
<p><span style="color: #0000ff;"><span style="color: #0000ff;"><span style="color: #000000;">&nbsp; &nbsp; &nbsp; 原因很简单，我是从A表中批量取到所有数据，然后又用</span></span></span>findOne方法一条条去B表中查询，A表中有2w数据，也就是要查B表2w次，虽然B表中已经建立索引，但这样的查询逻辑明显是不可接受。知道问题所在，解决方案也就清楚了：对B表进行批量查询：</p>
<div class="cnblogs_code">
<pre>db.A.find({}, {}, <span style="color: #0000ff;">function</span><span style="color: #000000;">(err, adata){
  </span><span style="color: #0000ff;">if</span> (err) <span style="color: #0000ff;">return</span><span style="color: #000000;"> callback(err);
  </span><span style="color: #008000;">//</span><span style="color: #008000;">得到A表中的所有数据</span>
  adata.toArray(<span style="color: #0000ff;">function</span><span style="color: #000000;">(err, aArray){
    </span><span style="color: #0000ff;">if</span> (err) <span style="color: #0000ff;">return</span><span style="color: #000000;"> callback(err);
    </span><span style="color: #0000ff;">var</span> len =<span style="color: #000000;"> aArray.length;
    </span><span style="color: #0000ff;">var</span> result =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">var</span> usernames =<span style="color: #000000;"> [];
    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">var</span> i = 0; i &lt; len; i++<span style="color: #000000;">) {
      </span><span style="color: #0000ff;">var</span> item =<span style="color: #000000;"> aArray[i];
      </span><span style="color: #0000ff;">var</span> username =<span style="color: #000000;"> item._id.username;
      usernames.push(username);
    }
    </span><span style="color: #0000ff;">var</span> op = {username: {$<span style="color: #0000ff;">in</span><span style="color: #000000;">: usernames}};
    </span><span style="color: #008000;">//</span><span style="color: #008000;">查看B表中这条数据</span>
    db.B.find(op, {}, <span style="color: #0000ff;">function</span><span style="color: #000000;">(err, bdata){
      ddata.toArray(</span><span style="color: #0000ff;">function</span><span style="color: #000000;">(err, barray){
        callback(barray);  
      })
    })
  })
})</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp;经过这样的优化，程序性能会有明显的提升。</p>
<p>&nbsp; &nbsp; &nbsp;希望对大家有所帮助。</p>
<p>&nbsp; &nbsp; &nbsp;</p>]]></description></item><item><title>mongodb优缺点</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/04/13/2446446.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Fri, 13 Apr 2012 14:34:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/04/13/2446446.html</guid><description><![CDATA[<p><a href="http://simpleframework.net/blog/v/67813.html">http://simpleframework.net/blog/v/67813.html</a></p>
<p>本文来源于对Quora上一个问答的整理，主要列举了<a href="http://blog.nosqlfan.com/tags/mongodb" rel="nofollow" target="_blank">MongoDB</a>身上一些局限的功能及目前做得不够好的地方。其中包括了原本就并非MongoDB想做的部分，也包括了MongoDB想做但没做好的方面。</p>
<ul>
<li>在32位系统上，不支持大于2.5G的数据。详见<a href="http://blog.mongodb.org/post/137788967/32-bit-limitations" rel="nofollow" target="_blank">这里</a></li>
<li>单个文档大小限制为 4 M/16 M（1.8版本后升为16M）</li>
<li>锁粒度太粗，MongoDB使用的是一把全局的读写锁，详见<a href="http://www.mongodb.org/display/DOCS/How+does+concurrency+work" rel="nofollow" target="_blank">这里</a></li>
<li>不支持join操作和事务机制，这个确实是非MongoDB要做的领域</li>
<li>对内存要求比较大，至少要保证热数据（索引，数据及系统其它开销）都能装进内存</li>
<li>用户权限方面比较弱，这一点MongoDB官方推荐的是将机器部署在安全的内网环境中，尽量不要用权限，详见<a href="http://www.mongodb.org/display/DOCS/Security+and+Authentication" rel="nofollow" target="_blank">这里</a></li>
<li>MapReduce在单个实例上无法并行，只有采用Auto-Sharding才能并行。这是由JS引擎的限制造成的</li>
<li>MapReduce的结果无法写入到一个被Sharding的Collection中，2.0版本对这个<a href="http://blog.nosqlfan.com/tags/%e9%97%ae%e9%a2%98" rel="nofollow" target="_blank">问题</a>的解决好像也不彻底</li>
<li>对于数组型的数据操作不够丰富</li>
<li>Auto-Sharding还存在很多问题，所谓的水平扩展也不是那么理想</li>
</ul>]]></description></item><item><title>用nodejs实现json和jsonp服务</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/03/20/2370688.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Tue, 20 Mar 2012 15:41:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/03/20/2370688.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; <span style="font-size: 16px;"><strong>一、JSON和JSONP</strong></span></p>
<p>&nbsp; &nbsp; &nbsp; JSONP的全称是JSON with Padding，由于同源策略的限制，XmlHttpRequest只允许请求当前源（协议，域名，端口）的资源。如果要进行跨域请求，我们可以通过使用html的script标记来进行跨域请求，并在相应中返回要执行的script代码，其中可以直接使用JSON传递javascript对象。这种跨域的通讯方式成为JSONP。</p>
<p>&nbsp; &nbsp; &nbsp; 由此我们可以看出两者的区别：</p>
<p>&nbsp; &nbsp; &nbsp; json： 一种轻量级的数据格式。</p>
<p>&nbsp; &nbsp; &nbsp; jsonp：为实现跨域，而采用的一种脚本注入方法。</p>
<p>&nbsp; &nbsp; &nbsp; 备注：要了解更多json，可以参见我原先写的一篇介绍json的文章：<span style="color: #0000ff;"><a href="http://www.cnblogs.com/lengyuhong/archive/2012/01/07/2262390.html"><span style="color: #0000ff;">《JSON那些事》</span></a></span></p>
<p><span style="color: #0000ff;"><span style="color: #0000ff;"><br /></span></span></p>
<p>&nbsp; &nbsp; &nbsp; <strong><span style="font-size: 16px;">二、实现</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 为了简单起见，我们要读取数据都是</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> data = {'name': 'jifeng', 'company': 'taobao'};</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 1. 服务器端代码：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> http = require(<span style="color: #800000;">'</span><span style="color: #800000;">http</span><span style="color: #800000;">'</span>);<br /><span style="color: #0000ff;">var</span> urllib = require(<span style="color: #800000;">'</span><span style="color: #800000;">url</span><span style="color: #800000;">'</span>);<br /><br /><span style="color: #0000ff;">var</span> port = <span style="color: #800080;">10011</span>;<br /><span style="color: #0000ff;">var</span> data = {<span style="color: #800000;">'</span><span style="color: #800000;">name</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">jifeng</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">company</span><span style="color: #800000;">'</span>: <span style="color: #800000;">'</span><span style="color: #800000;">taobao</span><span style="color: #800000;">'</span>};<br /><br />http.createServer(function(req, res){<br />  <span style="color: #0000ff;">var</span> <span style="color: #0000ff;">params</span> = urllib.parse(req.url, <span style="color: #0000ff;">true</span>);<br />  console.log(<span style="color: #0000ff;">params</span>);<br />  <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">params</span>.query &amp;&amp; <span style="color: #0000ff;">params</span>.query.callback) {<br />    <span style="color: #008000;">//</span><span style="color: #008000;">console.log(params.query.callback);</span><span style="color: #008000;"><br /></span>    <span style="color: #0000ff;">var</span> str =  <span style="color: #0000ff;">params</span>.query.callback + <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span> + JSON.stringify(data) + <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span>;<span style="color: #008000;">//</span><span style="color: #008000;">jsonp</span><span style="color: #008000;"><br /></span>    res.end(str);<br />  } <span style="color: #0000ff;">else</span> {<br />    res.end(JSON.stringify(data));<span style="color: #008000;">//</span><span style="color: #008000;">普通的json</span><span style="color: #008000;"><br /></span>  }     <br />}).listen(port, function(){<br />  console.log(<span style="color: #800000;">'</span><span style="color: #800000;">server is listening on port </span><span style="color: #800000;">'</span> + port);  <br />})</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 2. 游览器端代码，为方便起见，我直接用了jquery的方法</p>
<div class="cnblogs_code">
<pre>&lt;html&gt;  <br />&lt;head&gt;  <br />  &lt;script src="http://code.jquery.com/jquery-latest.js"&gt;&lt;/script&gt;  <br />  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;  <br />&lt;/head&gt;  <br />&lt;body&gt;  <br />&lt;script type="text/javascript"&gt;  <br /><span style="color: #0000ff;">function</span> get_jsonp() {  <br />  $.getJSON("http://10.232.36.110:10011?callback=?",  <br />  <span style="color: #0000ff;">function</span>(data) {<br />    $('#result').val('My name is: ' + data.name);  <br />  });  <br />}  <br />&lt;/script&gt;  <br />&lt;a href="javascript:get_jsonp();"&gt;Click me&lt;/a&gt;&lt;br /&gt;  <br />&lt;textarea id="result" cols="50" rows="3"&gt;&lt;/textarea&gt;  <br />&lt;/body&gt;  <br />&lt;/html&gt;  </pre>
</div>
<p>&nbsp; &nbsp; &nbsp;jquery中getJSON（）方法可以参见：<a href="http://www.w3school.com.cn/jquery/ajax_getjson.asp">http://www.w3school.com.cn/jquery/ajax_getjson.asp</a></p>
<p>&nbsp; &nbsp;&nbsp;</p>]]></description></item><item><title>linux的内存管理</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/03/14/2397089.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Wed, 14 Mar 2012 15:27:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/03/14/2397089.html</guid><description><![CDATA[<p>内存内存</p>]]></description></item><item><title>nodejs C/C++ Addons 中的指针操作</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/03/02/2377790.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Fri, 02 Mar 2012 15:55:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/03/02/2377790.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; 刚看到这个标题的时候，大家会觉得比较奇怪，nodejs是一门脚本语言，它又没有&ldquo;指针&rdquo;这个数据结构，怎么能操作指针呢 ？这个问题关键就是nodejs中的Buffers这个数据结构。</p>
<p>&nbsp; &nbsp; &nbsp; <strong><span style="font-size: 16px;">背景</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 自己做的一个项目需要是从网站上下载一个图片，然后用<span style="color: #0000ff;"><a href="http://zh.wikipedia.org/wiki/Libjpeg"><span style="color: #0000ff;">libjpeg</span></a></span>这个C类库对图像进行操作。程序架构是用nodejs写一个主运行程序，用C++扩展来调用libjpeg类库并实现底层的算法。libjpeg的8d版本中已经有两个接口解析图片信息，分别是从文件中读取和从内存中读取。</p>
<div class="cnblogs_code">
<pre>EXTERN(<span style="color: #0000ff;">void</span>) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));<br /><br />EXTERN(<span style="color: #0000ff;">void</span>) jpeg_mem_src JPP((j_decompress_ptr cinfo,<br />                  unsigned <span style="color: #0000ff;">char</span> * inbuffer,<br />                  unsigned <span style="color: #0000ff;">long</span> insize));</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;对应这两个接口，就有两套解决方案：1，先将图片下载到本地文件，然后再从本地文件读到内存； 2，直接将图片读取到本地内存。</p>
<p>&nbsp; &nbsp; &nbsp;显而易见，第二种方案更优：节省了大量的磁盘IO，提升速度。那接下来的问题就是如何写nodejs的C++扩展，得到一块内存指针，这就需要buffers出马了。</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;<span style="font-size: 16px;"><strong>解决方案</strong></span></p>
<p>&nbsp; &nbsp; &nbsp;开始具体的解决方案之前需要先了解如何编写nodejs的C/C++扩展，还是比较简单的。没做过相关开发的同学可以参看以下文章：</p>
<p>&nbsp; &nbsp; &nbsp;1. <span style="color: #0000ff;"><a href="http://nodejs.org/docs/latest/api/addons.html"><span style="color: #0000ff;">nodejs C/C++ Addon</span></a></span></p>
<p>&nbsp; &nbsp; &nbsp;2. <span style="color: #0000ff;"><a href="http://www.grati.org/?p=413"><span style="color: #0000ff;">编写nodejs原生扩展</span></a></span></p>
<p>&nbsp; &nbsp; &nbsp;3. <span style="color: #0000ff;"><a href="https://github.com/pquerna/node-extension-examples"><span style="color: #0000ff;">node-extension-examples</span></a></span></p>
<p>&nbsp; &nbsp; &nbsp;nodejs中buffers是一个比较重要的数据结构，典型应用就是读取文件内容和发送http请求，它们都能到相关buffers。查看nodejs的源码就会发现有这样的api：</p>
<div class="cnblogs_code">
<pre>  <span style="color: #0000ff;">static</span> inline <span style="color: #0000ff;">char</span>* Data(v8::Handle&lt;v8::Object&gt; obj) {<br />    <span style="color: #0000ff;">return</span> (<span style="color: #0000ff;">char</span>*)obj-&gt;GetIndexedPropertiesExternalArrayData();<br />  }<br /><br />  <span style="color: #0000ff;">static</span> inline <span style="color: #0000ff;">char</span>* Data(Buffer *b) {<br />    <span style="color: #0000ff;">return</span> Buffer::Data(b-&gt;handle_);<br />  }<br /><br />  <span style="color: #0000ff;">static</span> inline size_t Length(v8::Handle&lt;v8::Object&gt; obj) {<br />    <span style="color: #0000ff;">return</span> (size_t)obj-&gt;GetIndexedPropertiesExternalArrayDataLength();<br />  }<br /><br />  <span style="color: #0000ff;">static</span> inline size_t Length(Buffer *b) {<br />    <span style="color: #0000ff;">return</span> Buffer::Length(b-&gt;handle_);<br />  }</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;通过Data()函数得到buffer的内存指针，通过Length()得到这块内存的大小，非常有用吧。</p>
<p>&nbsp; &nbsp; &nbsp;这样的话，只要nodejs程序得到buffer，然后转化为v8中的object对象，再从这个object对象中得到这块内存的指针和内存大小，接下来就可以进行想要的指针操作了。重要的代码如下：</p>
<div class="cnblogs_code">
<pre>    Local&lt;Value&gt; arg1 = args[<span style="color: #800080;">0</span>];<br /><br />    <span style="color: #0000ff;">if</span> (Buffer::HasInstance(arg1)) {<br />      size_t size = Buffer::Length(arg1-&gt;ToObject());<br />      <span style="color: #0000ff;">char</span>* bufferdata = Buffer::Data(arg1-&gt;ToObject());<br />      <span style="color: #008000;">//</span><span style="color: #008000;">to do with size and bufferdata</span><span style="color: #008000;"><br /></span>      <br />      <span style="color: #0000ff;">return</span> scope.Close(Number::New(size)); <br />    }<br />    <span style="color: #0000ff;">else</span>{<br />      <span style="color: #0000ff;">return</span> scope.Close(Number::New(-<span style="color: #800080;">1</span>)); <br />    }</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;大功告成。</p>
<p>&nbsp; &nbsp; &nbsp;完整的代码可以参见：<a href="https://github.com/jifeng/node-buffer-extends">https://github.com/jifeng/node-buffer-extends</a></p>
<p>&nbsp; &nbsp; &nbsp;其他操作buffer的例子：<a href="https://github.com/bnoordhuis/node-buffertools/blob/master/buffertools.cc">https://github.com/bnoordhuis/node-buffertools/blob/master/buffertools.cc</a><br /><br /></p>
<p>&nbsp;</p>]]></description></item><item><title>javascript的函数定义的区别</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/29/2370687.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Wed, 29 Feb 2012 12:02:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/29/2370687.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; javascript中函数定义通常有两种方法：</p>
<p>&nbsp; &nbsp; &nbsp; 1. 普通的函数定义：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span> f1 (){}</pre>
</div>
<p>　　2. 变量式函数定义：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> f2 = <span style="color: #0000ff;">function</span>(){}</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;还有一种定义方法是new Function，由于这种方法并不常用，这里就不做解释了。</p>
<p>&nbsp; &nbsp; &nbsp;那这两种定义方法有什么不同呢？难道仅仅只是样子不同而已嘛？当然不是这样，我们来看个具体的例子吧，大家觉得以下代码的执行结果是什么？</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">if</span> (1 === 1) {<br />  tellAlert();<br />} <span style="color: #0000ff;">else</span>{<br />  <span style="color: #0000ff;">function</span> tellAlert(){<br />    alert('hello');<br />  }<br />}</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;执行结果是：会提示&ldquo;hello&rdquo;<br />&nbsp; &nbsp; &nbsp;那接下来这段代码呢？</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">if</span> (1 === 1) {<br />  tellAlert();<br />} <span style="color: #0000ff;">else</span>{<br />  <span style="color: #0000ff;">var</span> tellAlert = <span style="color: #0000ff;">function</span> (){<br />    alert('hello');<br />  }<br />}</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;执行结果是：游览器不会提示&ldquo;hello&rdquo;，chrome中的控制台还会报错：</p>
<p>&nbsp; &nbsp;&nbsp;<img src="http://pic002.cnblogs.com/images/2012/311780/2012022902202198.jpg" alt="" /></p>
<p>&nbsp; &nbsp; 从上例中，我们可以明显看出，两者很大的不同就是执行顺序不同，这是function语句在解析时会发生被提升的情况。<strong>也就是说不管function被放置在哪里，它都会被移动到被定义时所在作用域的顶层</strong>。这样的后果就是放宽了函数必须先声明后使用的要求。</p>
<p>&nbsp; &nbsp;<span style="color: #0000ff;"><a href="http://book.douban.com/subject/3590768/"><span style="color: #0000ff;">《javascript语言精粹》</span></a></span>中推荐使用的方法是 var f1 = function()。这样能明确表示f1 是一个包含一个函数值的变量。</p>
<p>&nbsp; &nbsp; &nbsp;而nodejs的源码中，定义函数的方法是function f1()。</p>
<p>&nbsp; &nbsp; &nbsp;个人感觉，在控制自己的代码逻辑的基础上，直接用function f1（）会更好点，代码会更清楚点。</p>
<p><br />&middot;</p>]]></description></item><item><title>nodejs 单元测试</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/26/2368774.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 26 Feb 2012 08:25:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/26/2368774.html</guid><description><![CDATA[<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a href="http://fengmk2.github.com/ppt/unittest-and-bdd-in-nodejs-with-mocha.html" target="_blank">http://fengmk2.github.com/ppt/unittest-and-bdd-in-nodejs-with-mocha.html</a></p>]]></description></item><item><title>mongodb部署时Master-Slave和Replica Set的原理讲解</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/21/2361728.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Tue, 21 Feb 2012 10:13:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/21/2361728.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp;mongodb的部署方式有三种，单机简单部署比较简单，这里主要讲解Master-Slave和Replica Set的原理，部署方法可以参见以前写的文章<a href="http://www.cnblogs.com/lengyuhong/archive/2012/02/20/2359355.html">《mongodb部署》</a></p>
<p>&nbsp;</p>]]></description></item><item><title>mongodb部署</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/21/2359355.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Tue, 21 Feb 2012 10:05:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/21/2359355.html</guid><description><![CDATA[<p>&nbsp;</p>
<p><strong>一、简单启动</strong></p>
<p>举例：</p>
<div class="cnblogs_code">
<pre>./mongod --dbpath /<span style="color: #0000ff;">var</span>/lib/mongodb/ --port <span style="color: #800080;">12345</span></pre>
</div>
<p>这中方法相对比较简单，这里不做具体的阐述，查看下面的文档即可</p>
<p><span style="color: #0000ff;"><a href="http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo"><span style="color: #0000ff;">http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo</span></a></span></p>
<p>&nbsp;</p>
<p><strong>二、master-slave</strong></p>
<p>&nbsp; &nbsp; &nbsp;1. 运行脚本脚本：</p>
<div class="cnblogs_code">
<pre>$ cd ~/apps<br />$ wget http:<span style="color: #008000;">//</span><span style="color: #008000;">fastdl.mongodb.org/linux/mongodb-linux-x86_64-1.8.3.tgz</span><span style="color: #008000;"><br /></span>$ tar zxvf mongodb-linux-x86_64-1.8.3.tgz<br />$ mv mongodb-linux-x86_64-1.8.3 mongodb<br /># master<br />./mongodb/bin/mongod --master --port 7891 --dbpath=/home/zhujiadun.pt/mongodbdata/master_slave/master/ --logpath=/home/zhujiadun.pt/mongodbdata/master_slave/master.log --fork<br /># slave 10 sec sync<br />./mongodb/bin/mongod --slave --port 7892 --source 10.232.36.110:7891 --slavedelay 10 --dbpath=/home/zhujiadun.pt/mongodbdata/master_slave/slave/ --logpath=/home/zhujiadun.pt/mongodbdata/master_slave/slave.log --fork</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; --fork：让mongodb以后台守护进程的方式运行。 作用相当于:</p>
<div class="cnblogs_code">
<pre>nohup ./mongodb/bin/mongod --master --port 27017 --dbpath=$HOME/data/mongodb --logpath=$HOME/data/mongodb.log &amp;</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 主备指定的数据文件地址（--logpath）必须是不同的，而且贮备都提供一个对外的端口号，以便监控相关情况。</p>
<p>&nbsp; &nbsp; &nbsp; 一个小技巧：http的监控接口是（mongodb端口+1000），比如默认创建的MongoDB服务监听的是27017端口，而28017（监听端口+1000） 是web admin interface 监听端口，这个28017就是Http Console监控端口。&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 2. 查看主备效果</p>
<p>&nbsp; &nbsp; &nbsp;主库插入：</p>
<p>&nbsp; &nbsp; &nbsp;<img src="http://pic002.cnblogs.com/images/2012/311780/2012022018003144.jpg" alt="" /></p>
<p>&nbsp; &nbsp; &nbsp;备库查询：</p>
<p>&nbsp; &nbsp;&nbsp;<img src="http://pic002.cnblogs.com/images/2012/311780/2012022018011392.jpg" alt="" data-markzhi="registered" /></p>
<p>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; 主服务器可以通过自己local库的slave集合查看从服务器列表</p>
<p>&nbsp; &nbsp; 从服务器可以通过自己local库的source集合查看主服务器信息或维护多个主服务器。 （一个slave服务器可以服务多个master服务器）</p>
<p>&nbsp;</p>
<p><strong>三、Replica Set（副本集）</strong></p>
<p>&nbsp; &nbsp; 启动脚本：</p>
<div class="cnblogs_code">
<pre>#start node1 mongodb<br />./mongodb/bin/mongod --dbpath=/home/zhujiadun.pt/mongodbdata/replica_set/node1/ --logpath=/home/zhujiadun.pt/mongodbdata/replica_set/node1.log --port 10001 --replSet blort/10.232.36.110:10002 --fork<br />#start node2 mongodb<br />./mongodb/bin/mongod --dbpath=/home/zhujiadun.pt/mongodbdata/replica_set/node2/ --logpath=/home/zhujiadun.pt/mongodbdata/replica_set/node2.log --port 10002 --replSet blort/10.232.36.110:10001 --fork<br />#start node3 mongodb<br />./mongodb/bin/mongod --dbpath=/home/zhujiadun.pt/mongodbdata/replica_set/node3/ --logpath=/home/zhujiadun.pt/mongodbdata/replica_set/node2.log --port 10003 --replSet blort/10.232.36.110:10001 --fork</pre>
</div>
<p>&nbsp; &nbsp; 启动第三个结点时，副本集有一个亮点就是有自动检测功能：在其中指定单台服务器后，MongoDB就会自动搜索并连接其余的结点。</p>
<p>&nbsp; &nbsp; 启动几台服务器之后，日志会会告诉你副本没有进行初始化，因为还差最后一步：在shell初始化</p>
<div class="cnblogs_code">
<pre># init the configure<br />./mongodb/bin/mongo <span style="color: #800080;">10.232</span>.<span style="color: #800080;">36.110</span>:<span style="color: #800080;">10001</span>/admin<br />db.runCommand({<span style="color: #800000;">"</span><span style="color: #800000;">replSetInitiate</span><span style="color: #800000;">"</span>:{<br />  <span style="color: #800000;">"</span><span style="color: #800000;">_id</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">blort</span><span style="color: #800000;">"</span>,<br />  <span style="color: #800000;">"</span><span style="color: #800000;">members</span><span style="color: #800000;">"</span> : [ <br />    {<br />      <span style="color: #800000;">"</span><span style="color: #800000;">_id</span><span style="color: #800000;">"</span> : <span style="color: #800080;">1</span>,<br />      <span style="color: #800000;">"</span><span style="color: #800000;">host</span><span style="color: #800000;">"</span> :  <span style="color: #800000;">"</span><span style="color: #800000;">10.232.36.110:10001</span><span style="color: #800000;">"</span><br />    },<br />    {<br />      <span style="color: #800000;">"</span><span style="color: #800000;">_id</span><span style="color: #800000;">"</span> : <span style="color: #800080;">2</span>,<br />      <span style="color: #800000;">"</span><span style="color: #800000;">host</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">10.232.36.110:10002</span><span style="color: #800000;">"</span><br />    },<br />    {<br />      <span style="color: #800000;">"</span><span style="color: #800000;">_id</span><span style="color: #800000;">"</span> : <span style="color: #800080;">3</span>,<br />      <span style="color: #800000;">"</span><span style="color: #800000;">host</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">10.232.36.110:10003</span><span style="color: #800000;">"</span><br />    }   <br />  ]<br />}})</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;举例：</p>
<p>&nbsp; &nbsp; &nbsp;<img src="http://pic002.cnblogs.com/images/2012/311780/2012022117520194.jpg" alt="" />&nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;<img src="http://pic002.cnblogs.com/images/2012/311780/2012022117525578.jpg" alt="" data-markzhi="registered" /></p>
<p>&nbsp; &nbsp; &nbsp;连接这个mongodb集群：</p>
<div class="cnblogs_code">
<pre>./mongodb/bin/mongo <span style="color: #800080;">10.232</span>.<span style="color: #800080;">36.110</span>:<span style="color: #800080;">10001</span>,<span style="color: #800080;">10.232</span>.<span style="color: #800080;">36.110</span>:<span style="color: #800080;">10002</span>,<span style="color: #800080;">10.232</span>.<span style="color: #800080;">36.110</span>:<span style="color: #800080;">10001</span><br />MongoDB shell version: <span style="color: #800080;">1.8</span>.<span style="color: #800080;">3</span><br />connecting to: <span style="color: #800080;">10.232</span>.<span style="color: #800080;">36.110</span>:<span style="color: #800080;">10001</span>,<span style="color: #800080;">10.232</span>.<span style="color: #800080;">36.110</span>:<span style="color: #800080;">10002</span>,<span style="color: #800080;">10.232</span>.<span style="color: #800080;">36.110</span>:<span style="color: #800080;">10001</span>/test<br />Tue Feb <span style="color: #800080;">21</span> <span style="color: #800080;">14</span>:<span style="color: #800080;">17</span>:<span style="color: #800080;">57</span> SyncClusterConnection connecting to [<span style="color: #800080;">10.232</span>.<span style="color: #800080;">36.110</span>:<span style="color: #800080;">10001</span>]<br />Tue Feb <span style="color: #800080;">21</span> <span style="color: #800080;">14</span>:<span style="color: #800080;">17</span>:<span style="color: #800080;">57</span> SyncClusterConnection connecting to [<span style="color: #800080;">10.232</span>.<span style="color: #800080;">36.110</span>:<span style="color: #800080;">10002</span>]<br />Tue Feb <span style="color: #800080;">21</span> <span style="color: #800080;">14</span>:<span style="color: #800080;">17</span>:<span style="color: #800080;">57</span> SyncClusterConnection connecting to [<span style="color: #800080;">10.232</span>.<span style="color: #800080;">36.110</span>:<span style="color: #800080;">10001</span>]<br />blort:PRIMARY&gt; </pre>
</div>
<p><br /><br /><br /><br /></p>
<p>官方文档：</p>
<p><a href="http://www.mongodb.org/display/DOCS/Replication">http://www.mongodb.org/display/DOCS/Replication</a></p>
<p>连接mongodb的方法：</p>
<p><a href="http://www.cnblogs.com/pipizhu/archive/2011/08/08/2130966.html">http://www.cnblogs.com/pipizhu/archive/2011/08/08/2130966.html</a></p>]]></description></item><item><title>Nodejs读写文件</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/18/2265164.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sat, 18 Feb 2012 12:50:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/18/2265164.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp;nodejs对文件的读写还是相当灵活的，可以根据不同的场景来选择不同的方法，具体可以参见：<a href="http://cnodejs.org/cman/fs.html">Nodejs fs</a></p>
<p>&nbsp; &nbsp; &nbsp;<strong><span style="font-size: 16px;">一.直接操作文件</span></strong></p>
<p>&nbsp; &nbsp; &nbsp;最简单的两个<span style="color: #0000ff;"><a href="http://cnodejs.org/cman/fs.html#fs.readFile"><span style="color: #0000ff;">fs.readFile</span></a></span>和<span style="color: #0000ff;"><a href="http://cnodejs.org/cman/fs.html#fs.writeFile"><span style="color: #0000ff;">fs.writeFile</span></a></span></p>
<p>　 &nbsp;举例：这个程序的功能是将一个比较大json格式的文件转换成你想自己要格式的文件。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> fs = require('fs');<br />fs.readFile('./json.json',<span style="color: #0000ff;">function</span>(err,data){<br />    <span style="color: #0000ff;">if</span>(err) <span style="color: #0000ff;">throw</span> err;<br /><br /><br />    <span style="color: #0000ff;">var</span> jsonObj = JSON.parse(data);<br />    <span style="color: #0000ff;">var</span> space = ' ';<br />    <span style="color: #0000ff;">var</span> newLine = '\n';<br />    <span style="color: #0000ff;">var</span> chunks = [];    <br />    <span style="color: #0000ff;">var</span> length = 0;<br /><br />    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> i=0,size=jsonObj.length;i&lt;size;i++){<br />        <span style="color: #0000ff;">var</span> one = jsonObj[i];<br />        <span style="color: #008000;">//</span><span style="color: #008000;">what value you want </span><span style="color: #008000;"><br /></span>        <span style="color: #0000ff;">var</span> value1 = one['value1'];<br />        <span style="color: #0000ff;">var</span> value2 = one['value2'];<br />        ....<br />        <span style="color: #0000ff;">var</span> value = value1 +space+value2+space+.....+newLine;<br />        <span style="color: #0000ff;">var</span> buffer = <span style="color: #0000ff;">new</span> Buffer(value);<br />        chunks.push(buffer);<br />        length += buffer.length;<br />    }<br />    <br />    <span style="color: #0000ff;">var</span> resultBuffer = <span style="color: #0000ff;">new</span> Buffer(length);<br />    <span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">var</span> i=0,size=chunks.length,pos=0;i&lt;size;i++){<br />        chunks[i].copy(resultBuffer,pos);<br />        pos += chunks[i].length;<br />    }<br />    <br />    fs.writeFile('./resut.text',resultBuffer,<span style="color: #0000ff;">function</span>(err){<br />        <span style="color: #0000ff;">if</span>(err) <span style="color: #0000ff;">throw</span> err;<br />        console.log('has finished');<br />    });<br />    <br />});</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;它的原理是将文件数据一次性全部读入内存，优点就是接下来都是在内存的操作，速度会很快。但缺点也很明显，就是当文件非常大时，会造成内存溢出。 &nbsp;</p>
<p>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<strong><span style="font-size: 16px;">二. 使用文件流</span></strong></p>
<p>　　 2.1 读取文件，api相见：<span style="color: #0000ff;"><a href="http://cnodejs.org/cman/fs.html#fs.ReadStream"><span style="color: #0000ff;">fs.createReadSream</span></a><span style="color: #0000ff;"><span style="color: #000000;">&nbsp;和</span>&nbsp;</span></span><span style="color: #0000ff;"><a href="http://cnodejs.org/cman/fs.html#fs.createWriteStream"><span style="color: #0000ff;">fs.createWriterStream</span></a></span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;以下代码实现的功能就是通过文件流来实现图片的复制：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> fs = require('fs');<br /><span style="color: #0000ff;">var</span> rOption = {<br />  flags : 'r',<br />  encoding : <span style="color: #0000ff;">null</span>,<br />  mode : 0666<br />}<br /><br /><span style="color: #0000ff;">var</span> wOption = {<br />  flags: 'a',<br />  encoding: <span style="color: #0000ff;">null</span>,<br />  mode: 0666   <br />}<br /><br /><span style="color: #0000ff;">var</span> fileReadStream = fs.createReadStream('./myjpg.jpg',rOption);<br /><span style="color: #0000ff;">var</span> fileWriteStream = fs.createWriteStream('./new_myjpg.jpg',wOption);<br /><br />fileReadStream.on('data',<span style="color: #0000ff;">function</span>(data){<br />  fileWriteStream.write(data);<br />    <br />});<br /><br />fileReadStream.on('end',<span style="color: #0000ff;">function</span>(){<br />  console.log('readStream end'); <br />  fileWriteStream.end();<br />});</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;这里再补充在流中非常有用的一个函数：<span style="color: #0000ff;"><a href="http://cnodejs.org/cman/streams.html#event_pipe_pipe_"><span style="color: #0000ff;">pipe</span></a></span>，它以用来把当前的可读流和另外一个可写流连接起来。可读流中的数据会被自动写入到可写流中。使用起来非常方便，依然实现上例中的功能：&nbsp; &nbsp; &nbsp;&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> fs = require('fs');<br /><br /><span style="color: #0000ff;">var</span> fileReadStream = fs.createReadStream('./myjpg.jpg');<br /><span style="color: #0000ff;">var</span> fileWriteStream = fs.createWriteStream('./new_myjpg.jpg');<br />fileReadStream.pipe(fileWriteStream);<br /><br />fileWriteStream.on('close',<span style="color: #0000ff;">function</span>(){<br />  console.log('copy over');  <br />});</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;用这个函数可以轻松地实现一个静态资源服务器：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> http = require("http");<br /><span style="color: #0000ff;">var</span> fs = require("fs"), <br /><span style="color: #0000ff;">var</span> path = require("path"), <br /><span style="color: #0000ff;">var</span> url = require("url"); <br /><br /><span style="color: #0000ff;">var</span> server = http.createServer(<span style="color: #0000ff;">function</span>(req, res) {<br />  <span style="color: #0000ff;">var</span> pathname = url.parse(req.url).pathname; <br />  console.log(pathname);<br />  <span style="color: #0000ff;">var</span> filepath = path.join("./tmp", "wwwroot", pathname); <br />  console.log(filepath);<br />  <span style="color: #0000ff;">var</span> stream = fs.createReadStream(filepath, {flags : "r", encoding : <span style="color: #0000ff;">null</span>}); <br />  stream.on("error", <span style="color: #0000ff;">function</span>() { <br />      res.writeHead(404); <br />      res.end(); <br />  }); <br />  stream.pipe(res);<br />}); <br />server.on("error", <span style="color: #0000ff;">function</span>(error) { <br />  console.log(error); <br />}); <br />server.listen(8088,<span style="color: #0000ff;">function</span>(){<br />  console.log('server listen on 8088');<br />});</pre>
</div>
<p>&nbsp;</p>]]></description></item><item><title>从V8引擎编程理解javascript执行环境</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/17/2353143.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 16 Feb 2012 16:06:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/17/2353143.html</guid><description><![CDATA[<p>&nbsp; &nbsp; <span style="font-size: 16px;"><strong>一、V8简介&nbsp;</strong></span></p>
<p>&nbsp; &nbsp; google code上对它的解释如下：</p>
<table border="1" align="center">
<tbody>
<tr>
<td>
<p>&nbsp; <span style="font-family: 仿宋; font-size: 14px;">&nbsp; &nbsp;<em>V8 is Google's open source JavaScript engine.</em></span></p>
<p><span style="font-family: 仿宋; font-size: 14px;"><em>&nbsp; &nbsp; V8 is written in C++ and is used in Google Chrome, the open source browser from Google.</em></span></p>
<p><span style="font-family: 仿宋; font-size: 14px;"><em>&nbsp; &nbsp; V8 implements ECMAScript as specified in&nbsp;<a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" rel="nofollow">ECMA-262</a>, 5th edition, and runs on Windows (XP or newer), Mac OS X (10.5 or newer), and Linux &nbsp; &nbsp; systems that use IA-32, x64, or ARM processors.</em></span></p>
<p><span style="font-family: 仿宋; font-size: 14px;"><em>&nbsp; &nbsp; V8 can run standalone, or can be&nbsp;embedded&nbsp;into any C++ application.</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp; &nbsp; 翻译过来重点就是：V8引擎是一个google开发的开源javascript引擎，它是由C++编写而成，被用在google的开源游览器chrome上。</p>
<p>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; <span style="font-size: 16px;"><strong>二、Hello World</strong></span></p>
<p>&nbsp; &nbsp; 学习任何一门语言，&ldquo;hello world&rdquo;往往是我们的第一步，这里也不例外，代码如下：</p>
<div class="cnblogs_code">
<pre>#include &lt;v8.h&gt;<br /><br /><span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span> v8;<br /><br /><span style="color: #0000ff;">int</span> main(<span style="color: #0000ff;">int</span> argc, <span style="color: #0000ff;">char</span>* argv[]) {<br /><br />  <span style="color: #008000;">//</span><span style="color: #008000;"> Create a stack-allocated handle scope.</span><span style="color: #008000;"><br /></span>  HandleScope handle_scope;<br /><br />  <span style="color: #008000;">//</span><span style="color: #008000;"> Create a new context.</span><span style="color: #008000;"><br /></span>  Persistent&lt;Context&gt; context = Context::New();<br />  <br />  <span style="color: #008000;">//</span><span style="color: #008000;"> Enter the created context for compiling and<br />  </span><span style="color: #008000;">//</span><span style="color: #008000;"> running the hello world script. </span><span style="color: #008000;"><br /></span>  Context::Scope context_scope(context);<br /><br />  <span style="color: #008000;">//</span><span style="color: #008000;"> Create a string containing the JavaScript source code.</span><span style="color: #008000;"><br /></span>  Handle&lt;String&gt; source = String::New(<span style="color: #800000;">"</span><span style="color: #800000;">'Hello' + ', World!'</span><span style="color: #800000;">"</span>);<br /><br />  <span style="color: #008000;">//</span><span style="color: #008000;"> Compile the source code.</span><span style="color: #008000;"><br /></span>  Handle&lt;Script&gt; script = Script::Compile(source);<br />  <br />  <span style="color: #008000;">//</span><span style="color: #008000;"> Run the script to get the result.</span><span style="color: #008000;"><br /></span>  Handle&lt;Value&gt; result = script-&gt;Run();<br />  <br />  <span style="color: #008000;">//</span><span style="color: #008000;"> Dispose the persistent context.</span><span style="color: #008000;"><br /></span>  context.Dispose();<br /><br />  <span style="color: #008000;">//</span><span style="color: #008000;"> Convert the result to an ASCII string and print it.</span><span style="color: #008000;"><br /></span>  String::AsciiValue ascii(result);<br />  printf(<span style="color: #800000;">"</span><span style="color: #800000;">%s\n</span><span style="color: #800000;">"</span>, *ascii);<br />  <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span>;<br />}</pre>
</div>
<p>&nbsp; &nbsp; 具体的编译运行方法可以参见，如下文章：<span style="color: #0000ff;"><a href="http://code.google.com/intl/zh-CN/apis/v8/get_started.html"><span style="color: #0000ff;">http://code.google.com/intl/zh-CN/apis/v8/get_started.html</span></a></span></p>
<p>&nbsp; &nbsp; 作为一名nodejs 的开发者，我要补充一个已经安装好node之后如何正常编译运行该代码，众所周知，nodejs是以来v8引擎的，也就是说当你成功安装好nodejs之后就已经成功安装好v8了，具体方法：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> v8 在安装nodejs时已经安装完毕<br /></span><span style="color: #008000;">//</span><span style="color: #008000;"> 比如在自己目录(/home/zhujiadun.pt/)中下载了node-v0.6.10，默认安装<br /></span><span style="color: #008000;">//</span><span style="color: #008000;"> 具体：<br /></span><span style="color: #008000;">//</span><span style="color: #008000;">    1. v8.h和v8stdint.h 两个头文件在~/node-v0.6.10/deps/v8/include/和/usr/local/include/node/都有一份 <br /></span><span style="color: #008000;">//</span><span style="color: #008000;">    2. libv8.a可以在~/node-v0.6.10/out/Release/libv8.a找到<br /></span><span style="color: #008000;">//</span><span style="color: #008000;"> 运行方法<br /></span><span style="color: #008000;">//</span><span style="color: #008000;"> 1. 将v8.h和v8stdint.h 拷贝到 /usr/include <br /></span><span style="color: #008000;">//</span><span style="color: #008000;"> 2. 将libv8.a拷贝到这个文件目录<br /></span><span style="color: #008000;">//</span><span style="color: #008000;"> 3. g++  hello_world.cpp -o hello_world libv8.a -lpthread<br /></span><span style="color: #008000;">//</span><span style="color: #008000;"> 4. ./hello_world</span></pre>
</div>
<p>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; <strong><span style="font-size: 16px;">三、执行环境讲解</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; js作用域的基础知识参见：<span style="color: #0000ff;"><a class="titlelink" href="http://www.cnblogs.com/lengyuhong/archive/2012/01/08/2316234.html"><span style="color: #0000ff;">《javascript高级程序设计》读书笔记&mdash;&mdash;作用域</span></a></span><br />&nbsp; &nbsp; &nbsp; 强调了这么多，终于可以进入正题，通过v8的编程来体验一把javascript执行环境相关知识。</p>
<p>&nbsp; &nbsp; &nbsp; 以上这幅图的运行原理过程图（图片直接来源google的v8介绍）：</p>
<p>&nbsp; &nbsp;&nbsp;<img src="http://pic002.cnblogs.com/images/2012/311780/2012021623114491.png" alt="" width="497" height="200" data-markzhi="registered" /></p>
<p>&nbsp; &nbsp; 讲解几个概念：</p>
<p>&nbsp; &nbsp; 执行环境：</p>
<pre> Persistent&lt;Context&gt; context = Context::New();</pre>
<pre> Context::Scope context_scope(context);</pre>
<pre> context.Dispose();</pre>
<p>&nbsp; &nbsp; context就是这个函数的执行环境，在javascript中执行环境是一个非常重要的概念，每个函数被在调用时都会创建自己的执行环境，由它来定义代码在哪个环境被执行。当函数执行完毕时被销毁。</p>
<p>&nbsp; &nbsp; handle：</p>
<p>&nbsp; &nbsp; v8引擎如jvm一样，会自动对不用的内存进行垃圾回收，handle就是告诉v8的垃圾回收器这个函数在堆中位置。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; 文本只是对v8的相关知识进行初步的讲解，v8还是比较复杂的，很多内容还在学习当中，先简单分享些自己的学习心得吧。</p>
<p>&nbsp; &nbsp; 参考资料：</p>
<p>&nbsp; &nbsp;&nbsp;<a href="http://code.google.com/intl/zh-CN/apis/v8/intro.html">http://code.google.com/intl/zh-CN/apis/v8/intro.html</a></p>
<p>&nbsp; &nbsp;&nbsp;<a href="http://izs.me/v8-docs/main.html">http://izs.me/v8-docs/main.html</a></p>
<pre> </pre>
<p>&nbsp; &nbsp;&nbsp;<br /><br /></p>]]></description></item><item><title>学习笔记 《鸟哥的私房菜——软件安装：源码和Tarball》</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/09/2344638.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 09 Feb 2012 15:22:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/09/2344638.html</guid><description><![CDATA[<p>文章原文：</p>
<p><a href="http://linux-vbird.bluedata.org/linux_base/0520source_code_and_tarball.htm#library_dyna_sta">http://linux-vbird.bluedata.org/linux_base/0520source_code_and_tarball.htm#library_dyna_sta</a></p>
<p>&nbsp;</p>
<p>重点学习内容：</p>
<p>一、 源码的编译：</p>
<p>&nbsp; &nbsp; &nbsp;特别注意-l 和-L两个参数，在使用到外部函数库时是非常重要的。</p>
<div class="cnblogs_code">
<pre>[guest@test guest]# gcc sin.c -lm -L/lib -L/usr/lib <br /># 特别注意，那个 -lm 可以拆开成两部份来看， <br /># -l 是『加入某个函式库(library)』的意思，而m 则是 libm.so 这个函式库，其中， lib 与附档名(.a 或 .so)不需要写 <br /># 所以 -lm 表示使用 libm.so (或 libm.a) 这个函式库的意思～ ，这个语句可以写多次，比如<br /># 至于那个 -L 后面接的路径呢？这表示： <br />#『我要的函式库 libm.so 请到 /lib 或 /usr/lib 里面搜寻！』&nbsp;</pre>
<pre>[guest@test guest]# ./a.<span style="color: #0000ff;">out</span> <br /><span style="color: #800080;">1.000000</span></pre>
</div>
<p>&nbsp; &nbsp; 补充：</p>
<p>&nbsp; &nbsp; 头文件：g++ 时，默认的头文件都存在/usr/include，基本上大部分unix和linux都是这样的，可以用<span>gcc &nbsp; -I/usr/myinclude &nbsp; 来设置自己的包含路径</span>&nbsp;</p>
<p>&nbsp;</p>
<p>二、动态和静态函数库：</p>
<table border="2">
<tbody>
<tr>
<td>&nbsp;</td>
<td>静态函数库</td>
<td>&nbsp; &nbsp; 动态函数库 &nbsp;&nbsp;</td>
</tr>
<tr>
<td>扩展名</td>
<td>
<p>通常为libXXX.a &nbsp; &nbsp; &nbsp;&nbsp;</p>
</td>
<td>&nbsp; 通常为libXXX.so</td>
</tr>
<tr>
<td>编译行为</td>
<td>
<p>这类函数库在编译的时候会直接整合到执行程序当中，</p>
<p>所以利用静态函数库编译成的文件会比较大一点</p>
</td>
<td>
<p>动态函数库在编译的时候，在程序里面只有一个&ldquo;指向&rdquo;（Pointer，我的理解就个指针）</p>
<p>的位置而已。也就是说，动态函数的内容并没有整合到可执行的文件当中，而是当可执行</p>
<p>文件要使用到函数库的机制时，程序才去读取函数库来使用。由于可执行文件仅具有执行</p>
<p>动态函数库所在的指针而已，并不包含函数库的内容。所以它的文件会小一点</p>
</td>
</tr>
<tr>
<td>独立执行的状态</td>
<td>
<p>&nbsp;它最大的优点，编译成功的可执行文件可以独立执行，</p>
<p>&nbsp;而不需要再向外部要求读取函数库的内容</p>
</td>
<td>
<p>这类型的函数库所编译出来的程序不能独立执行，因为当我们使用到函数库时，程序才会去</p>
<p>读取函数库，所以函数库文件必须存在才行，而且函数库的所在目录也不能改变，因为我们</p>
<p>的可执行文件里面仅有&ldquo;指标&rdquo;，亦即当要取用该动态函数库时，程序会主动去某个路径下读取，</p>
<p>所以动态函数库可不能随意移动或删除，会影响到很多相关的程序&nbsp;</p>
</td>
</tr>
<tr>
<td>升级难易度</td>
<td>
<p>虽然可执行文件可以单独执行，但因为函数库时直接整合到</p>
<p>可执行文件，因此若函数库升级时，整个可执行必须要重新</p>
<p>编译才能将新版的函数库整合到程序当中，也就是说，在升</p>
<p>级方面，只要函数库升级了，所有将此函数库纳入的程序都</p>
<p>必须重新编译&nbsp;</p>
</td>
<td>
<p>&nbsp;当函数库升级后，可执行文件根本不需要进行重新编译的行为，因为可执行文件会直接指向</p>
<p>新的函数库文件（前提是函数库新旧版本的文件名相同）</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; 目前Linux distribution比较倾向于使用动态库，处于的考虑是升级的方便。</p>
<p>&nbsp; &nbsp; 绝大多数的函数库防止在/usr/bin，/lib目录下，此外，linux系统里面的函数其实kernel就提供了，它放在/lib/modules里面</p>
<p>&nbsp;</p>]]></description></item><item><title>学习笔记《LibJpeg》</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/07/2341965.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Tue, 07 Feb 2012 13:39:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/07/2341965.html</guid><description><![CDATA[<p>&nbsp; &nbsp; libjpeg简介：</p>
<p>&nbsp; &nbsp; libjpeg是一个完全用C语言编写的库，包含了被广泛使用的jpeg解码、jpeg编码和其他jpeg功能的实现。这个库由独立jpeg工作组维护，具体可以参考<span style="color: #0000ff;"><a href="http://zh.wikipedia.org/wiki/Libjpeg"><span style="color: #0000ff;">维基百科关于libjpeg介绍&nbsp;</span></a></span></p>
<p>&nbsp; &nbsp; 相关文章：</p>
<p>&nbsp; &nbsp;&nbsp;<span style="color: #0000ff;"><a href="http://my.unix-center.net/~Simon_fu/?p=565"><span style="color: #0000ff;">LibJpeg解码内存中的Jpeg数据</span></a></span></p>
<p>&nbsp; &nbsp;&nbsp;<span style="color: #0000ff;"><a href="http://my.unix-center.net/~Simon_fu/?p=1026"><span style="color: #0000ff;">图像解码之一&mdash;&mdash;只用libjpeg解码jpeg图片</span></a></span></p>
<p>&nbsp; &nbsp;&nbsp;<span style="color: #0000ff;"><a href="http://www.ijg.org/files/"><span style="color: #0000ff;">相关源码</span></a></span></p>
<p>&nbsp; &nbsp; 基础知识文章：</p>
<p>&nbsp; &nbsp;&nbsp;<span style="color: #0000ff;"><a href="http://blog.csdn.net/hermit/article/details/2029396"><span style="color: #0000ff;">嵌入式linux下libjpeg的小例子</span></a></span></p>
<p>&nbsp; &nbsp;&nbsp;<span style="color: #0000ff;"><a href="http://www.chinaunix.net/jh/23/408225.html"><span style="color: #0000ff;">跟我一起来写 Makefile</span></a></span></p>
<p><span style="color: #0000ff;"><span style="color: #0000ff;">&nbsp; &nbsp;&nbsp;</span></span></p>
<p>&nbsp;</p>]]></description></item><item><title>学习笔记 《浏览器内部工作原理》</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/05/2338998.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 05 Feb 2012 06:47:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/05/2338998.html</guid><description><![CDATA[<p>浏览器内部工作原理：</p>
<p>中文版：<a href="http://www.cnblogs.com/cnwebdeveloper/articles/2234423.html">http://www.cnblogs.com/cnwebdeveloper/articles/2234423.html</a></p>
<p>英文版：<a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/</a></p>
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="http://pic002.cnblogs.com/images/2012/311780/2012051823364123.png" alt="" /></p>
<p style="text-align: center;"><span style="font-size: 15px;">游览器主要组件</span></p>
<p>&nbsp;</p>
<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</p>
<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;浏览器引擎－ 用来查询及操作渲染引擎的接口</p>
<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;渲染引擎－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</p>
<p>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</p>
<p>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UI&nbsp;后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</p>
<p>6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JS解释器－ 用来解释执行JS代码</p>
<p>7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术</p>
<p>&nbsp;</p>
<p>渲染引擎相关</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>网络请求</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>HTTP中的URL长度限制</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/04/2330130.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sat, 04 Feb 2012 13:45:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/04/2330130.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp;由于之前的一个web项目中，要用get方法去获取数据，但结果时常报错，经过仔细排查才发现原来url长度超过了限制，通过缩短url和发送多次请求的方法解决了该问题，之后在网上查了些资料，发现这个问题还是内藏玄机，要比自己想的复杂。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;首先，其实http 1.1 协议中对url的长度是不受限制的，协议原文：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<em><span style="font-family: 仿宋;">The HTTP protocol does not place any a priori limit on the length of a URI. Servers MUST be able to handle the URI of any resource they&nbsp;serve, and SHOULD be able to handle URIs of unbounded length if they provide GET-based forms that could generate such URIs. A server SHOULD return 414 (Request-URI Too Long) status if a URI is longer than the server can handle (see section 10.4.15).</span></em></p>
<pre>  <span style="font-family: 仿宋;"><em>Note: Servers ought to be cautious about depending on URI lengths above 255 bytes, because some older client or proxyimplementations might not properly support these lengths.</em></span></pre>
<p>翻译：</p>
<p><em><span style="font-family: 仿宋;"><span lang="EN-US" xml:lang="EN-US">&nbsp; &nbsp; &nbsp;HTTP</span>协议不对<span lang="EN-US" xml:lang="EN-US">URI</span>的长度作事先的限制，服务器必须能够处理任何他们提供资源的<span lang="EN-US" xml:lang="EN-US">URI</span>，并且应该能够处理无限长度的<span lang="EN-US" xml:lang="EN-US">URIs</span>，这种无效长度的<span lang="EN-US" xml:lang="EN-US">URL</span>可能会在客户端以基于<span lang="EN-US" xml:lang="EN-US">GET</span>方式的请求时产生。如果服务器不能处理太长的<span lang="EN-US" xml:lang="EN-US">URI</span>的时候，服务器应该返回<span lang="EN-US" xml:lang="EN-US">414</span>状态码（此状态码代表<span lang="EN-US" xml:lang="EN-US">Request-URI</span>太长）。</span></em></p>
<p><em><span style="font-family: 仿宋;">&nbsp; &nbsp; 注<span lang="EN-US" xml:lang="EN-US">:</span>服务器在依赖大于<span lang="EN-US" xml:lang="EN-US">255</span>字节的<span lang="EN-US" xml:lang="EN-US">URI</span>时应谨慎，因为一些旧的客户或代理实现可能不支持这些长度。</span></em></p>
<p>&nbsp; &nbsp; 具体参见<a href="http://www.ietf.org/rfc/rfc2616.txt">协议</a>&nbsp;中的3.2.1</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;虽然协议中未明确对url进行长度限制，但在真正实现中，url的长度还是受到限制的，一是服务器端的限制，二就是游览器端的限制。</p>
<p>&nbsp; &nbsp; &nbsp;一、服务器端</p>
<p>&nbsp; &nbsp; &nbsp;在服务器端，主要是apache，jboss和nginx等，我在网上找到的调节方法可以参加下文：<a href="http://blog.sina.com.cn/s/blog_62fc65d90100onhm.html">关于http请求url长度以及请求消息体长度的研究（一）（服务器端）</a></p>
<p>&nbsp; &nbsp; 1.1 nginx&nbsp;</p>
<p>&nbsp; &nbsp; 由于现在项目中主要用到nginx，所以强调下它的设置参数：<span style="color: #0000ff;">large_client_header_buffers</span></p>
<p><span style="color: #000000;">&nbsp; &nbsp; 该参数对nginx服务器接受客户端请求的头信息时所分配的最大缓冲区的大小做了限制，也就是nginx服务器一次接受一个客户端请求可就收的最大头信息大小。这个头不仅包含 request-line，还包括通用信息头、</span><span>请求头域、</span><span>响应头域的长度总和。这也相当程度的限制了url的长度。</span></p>
<p><span style="color: #0000ff;">&nbsp; &nbsp; &nbsp;nginx服务器默认的限制</span><span><span style="color: #0000ff;">是4K或者8K</span>，这是根据服务器的硬件配置有关的，一般为内存一页的大小，目前大部分为4K，即4096字节。</span></p>
<p><span>&nbsp; &nbsp; &nbsp;</span></p>
<p><span>&nbsp; &nbsp; 1.2 nodejs</span></p>
<p>&nbsp; &nbsp; &nbsp;这主要是针对nodejs程序员，如不做相关开发可以直接忽略这一节。</p>
<p>&nbsp; &nbsp; &nbsp;nodejs的http服务，设置url长度限制和headers的大小还是相对比较灵活的，我简单实现了控制程序，这里_limit就是url长度的控制器</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> http = require('http');<br /><br /><span style="color: #0000ff;">var</span> _limit = 40;<br /><br /><span style="color: #0000ff;">var</span> app = http.createServer(<span style="color: #0000ff;">function</span>(req,res){<br />  console.log('hello world');<br />  <span style="color: #0000ff;">var</span> potocol = 'http:\/\/';<br />  <span style="color: #0000ff;">var</span> host = req.headers.host;<br />  <span style="color: #0000ff;">var</span> url = req.url;<br />  <br />  <span style="color: #0000ff;">var</span> code = 200;<br />  <span style="color: #0000ff;">var</span> allurl  = potocol + host + url;<br />  console.log(allurl);<br />  <span style="color: #0000ff;">var</span> len = allurl.length;<br />  <span style="color: #0000ff;">if</span>(len &gt; _limit){<br />    <span style="color: #0000ff;">var</span> code = 414;<br />    res.writeHead(code, {});<br />    res.end();<br />  }<br />  <span style="color: #0000ff;">else</span>{<br />    <span style="color: #0000ff;">var</span> body = {'name':'jifeng'};<br />    res.writeHead(code, {});<br />    res.end(JSON.stringify(body));<br />  }<br />});<br /><br />app.listen(1987,<span style="color: #0000ff;">function</span>(){<br />  console.log('server listen on 1987');  <br />});</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;备注：&nbsp;<a href="https://github.com/senchalabs/connect">connect</a>中的<a href="https://github.com/senchalabs/connect/blob/master/lib/middleware/limit.js#L8">limit</a>中有实现相类似功能的模块，<br />&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;二、游览器端</p>
<p>&nbsp; &nbsp; &nbsp;游览器的种类繁多，并且对URL的长度限制是有所差异的，具体如下：</p>
<table border="1" align="left">
<tbody>
<tr>
<td>游览器</td>
<td>最大长度（字符数） &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>备注</td>
</tr>
<tr>
<td><span>&nbsp;Internet Explorer &nbsp;</span></td>
<td><span>2083 &nbsp; &nbsp;&nbsp;</span></td>
<td><span>如果超过这个数字，提交按钮没有任何反应</span></td>
</tr>
<tr>
<td><span>&nbsp;Firefox</span></td>
<td><span>65,536</span></td>
<td>&nbsp;</td>
</tr>
<tr>
<td><span>&nbsp;chrome</span></td>
<td><span>8182</span></td>
<td>&nbsp;</td>
</tr>
<tr>
<td><span>&nbsp;Safari&nbsp;</span></td>
<td><span>80,000</span></td>
<td>&nbsp;</td>
</tr>
<tr>
<td><span>&nbsp;Opera</span></td>
<td><span>190,000</span></td>
<td>&nbsp;</td>
</tr>
<tr>
<td><span>curl（linux下指令）</span></td>
<td><span><span>8167</span></span></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; 这些数据主要通过网上数据搜索而来，笔者还没有亲自验证过。但都有限制是不争的事实，大家在做开发时要特别注意。</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>学习笔记《Defense hash algorithm collision 防御hash算法冲突导致拒绝服务器》</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/02/04/2338227.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sat, 04 Feb 2012 10:48:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/02/04/2338227.html</guid><description><![CDATA[<p>&nbsp; &nbsp; 原文地址：<a href="http://www.cnblogs.com/fengmk2/archive/2012/01/01/2309261.html">Defense hash algorithm collision 防御hash算法冲突导致拒绝服务器</a></p>
<p>&nbsp; &nbsp; 这是去年年底时发现的一个比较大的bug，由于这是涉及相对底层的算法，因此波及到了很多语言，造成很多程序员快要过年时还不得不紧急修复bug。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>javascript的事件处理（二）——跨游览器编程</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/01/16/2322681.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 16 Jan 2012 13:27:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/01/16/2322681.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; <strong><span style="font-size: 16px;">IE 与DOM游览器的区别</span></strong></p>
<p>&nbsp; &nbsp; &nbsp; 在上文<a href="http://www.cnblogs.com/lengyuhong/archive/2012/01/16/2322608.html">《javascript的事件处理（一）&mdash;&mdash;基础原理》</a>中的各种例子，addEventListener()产生的事件监听在chrome和firfox中有效，但在IE中是无效，这是因为IE实现了类似与DOM中类似的两个方法:attachEvent()和detachEvent()，使用方法值DOM的相类似，不同的是IE只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到<span style="color: #0000ff;">冒泡阶段</span>。具体代码如下：</p>
<div class="cnblogs_code">
<pre>&lt;button id = <span style="color: #800000;">'</span><span style="color: #800000;">mybutton5</span><span style="color: #800000;">'</span> &gt;Button5&lt;/button&gt;<br />&lt;script type = <span style="color: #800000;">'</span><span style="color: #800000;">text/javascript</span><span style="color: #800000;">'</span>&gt;<br />    <br />      <span style="color: #0000ff;">var</span> bn5 = document.getElementById(<span style="color: #800000;">'</span><span style="color: #800000;">mybutton5</span><span style="color: #800000;">'</span>);<br />      bn5.attachEvent(<span style="color: #800000;">'</span><span style="color: #800000;">onclick</span><span style="color: #800000;">'</span>,function(){<br />        alert(<span style="color: #800000;">'</span><span style="color: #800000;">IE attachEvent</span><span style="color: #800000;">'</span>);<br />      });<br />    <br />      bn5.detachEvent(<span style="color: #800000;">'</span><span style="color: #800000;">onclick</span><span style="color: #800000;">'</span>,function(){<br />        <span style="color: #008000;">//</span><span style="color: #008000;">do something  </span><span style="color: #008000;"><br /></span>      });<br />    <br />&lt;/script&gt;</pre>
</div>
<p>&nbsp; &nbsp; 它与DOM区别：</p>
<p>&nbsp; &nbsp; 1. attachEvent()的第一个参数时&ldquo;onclick&rdquo;，而addEVentListener()则是&ldquo;click&rdquo;。</p>
<p>&nbsp; &nbsp; 2. 作用域不同。attachEvent()中处理程序会在全局作用域中运行，this等于window，而DOM级方法中，处理程序会在所属元素的作用域中运行。</p>
<p>&nbsp; &nbsp; 3. attachEvent()和addEventListener()都可以为同一元素添加多个事件处理程序，DOM是按照添加它们的顺序执行，而IE则是按相反顺序被执行。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; <strong><span style="font-size: 16px;">跨游览器的事件处理程序</span></strong></p>
<p>&nbsp; &nbsp; 1. 自己写程序，原理很简单，先对游览器进行能力检测，再添加方法，具体：</p>
<div class="cnblogs_code">
<pre>&lt;button id = <span style="color: #800000;">'</span><span style="color: #800000;">mybutton7</span><span style="color: #800000;">'</span> &gt;Button7&lt;/button&gt;<br />&lt;script type = <span style="color: #800000;">'</span><span style="color: #800000;">text/javascript</span><span style="color: #800000;">'</span>&gt;<br />      <span style="color: #0000ff;">var</span> EventUtil = function(){};<br />      EventUtil.prototype.addHadler = function(element,action,hadler){<br />        <span style="color: #0000ff;">if</span>(element.addEventListener){<br />          alert(<span style="color: #800000;">'</span><span style="color: #800000;">addEventListener function</span><span style="color: #800000;">'</span>);<br />          element.addEventListener(action,hadler,<span style="color: #0000ff;">false</span>);  <br />        }<br />        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(element.attachEvent){<br />          alert(<span style="color: #800000;">'</span><span style="color: #800000;">attachEvent function</span><span style="color: #800000;">'</span>);<br />          element.attachEvent(<span style="color: #800000;">'</span><span style="color: #800000;">on</span><span style="color: #800000;">'</span>+action,hadler); <br />        }<br />        <span style="color: #0000ff;">else</span>{<br />          alert(<span style="color: #800000;">'</span><span style="color: #800000;">element["on"+action]</span><span style="color: #800000;">'</span>);<br />          element[<span style="color: #800000;">'</span><span style="color: #800000;">on</span><span style="color: #800000;">'</span>+action] = hadler;<br />        }<br />      }<br />      <br />      EventUtil.prototype.removeHadler = function(element,action,hadler){<br />        <span style="color: #0000ff;">if</span>(element.removeEventListener){<br />          element.removeEventListener(action,hadler,<span style="color: #0000ff;">false</span>);  <br />        }<br />        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(element.detachEvent){<br />          element.detachEvent(<span style="color: #800000;">'</span><span style="color: #800000;">on</span><span style="color: #800000;">'</span>+action,hadler); <br />        }<br />        <span style="color: #0000ff;">else</span>{<br />          element[<span style="color: #800000;">'</span><span style="color: #800000;">on</span><span style="color: #800000;">'</span>+action] = <span style="color: #0000ff;">null</span>;<br />        }<br />      <br />      }<br />      <br />      <span style="color: #0000ff;">var</span> hadlerfunction = function(){<br />        alert(<span style="color: #800000;">'</span><span style="color: #800000;">hadlefunction</span><span style="color: #800000;">'</span>);  <br />      } <br />    <br />      <span style="color: #0000ff;">var</span> bn7 = document.getElementById(<span style="color: #800000;">'</span><span style="color: #800000;">mybutton7</span><span style="color: #800000;">'</span>);<br />      <span style="color: #0000ff;">var</span> eu = <span style="color: #0000ff;">new</span> EventUtil();<br />      <br />      eu.addHadler(bn7,<span style="color: #800000;">'</span><span style="color: #800000;">click</span><span style="color: #800000;">'</span>,hadlerfunction);   <br />      <br />    <br />&lt;/script&gt;</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 这里为了方面起见，我使用了面向对象的逻辑，创建一个名叫EventUtil的对象，它有两个方法addHadler和removeHadler，分别用来注册和删除事件处理程序。</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 2. jquery类库</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<a href="http://jquery.com/">jquery</a>是javascript的一个类库，能极大地方便简化javascript的编程</p>
<div class="cnblogs_code">
<pre>&lt;script type = <span style="color: #800000;">'</span><span style="color: #800000;">text/javascript</span><span style="color: #800000;">'</span> src = <span style="color: #800000;">'</span><span style="color: #800000;">./jquery.js</span><span style="color: #800000;">'</span>&gt;&lt;/script&gt;<br />&lt;script type = <span style="color: #800000;">'</span><span style="color: #800000;">text/javascript</span><span style="color: #800000;">'</span>&gt;<br />    $(document).ready(function(){<br />      $(<span style="color: #800000;">'</span><span style="color: #800000;">#mybutton6</span><span style="color: #800000;">'</span>).click(function(){<br />        alert(<span style="color: #800000;">'</span><span style="color: #800000;">jquery button6 </span><span style="color: #800000;">'</span>);  <br />      });<br />    });<br />&lt;/script&gt;  <br />  <br /><br />&lt;button id = <span style="color: #800000;">'</span><span style="color: #800000;">mybutton6</span><span style="color: #800000;">'</span> &gt;Button6&lt;/button&gt;</pre>
</div>
<p><br />&nbsp; &nbsp; &nbsp;</p>
<p>这两篇文章主要是自己的学习笔记，大部分内容可以参见《javascript高级程序设计》中的事件一章。&nbsp;</p>]]></description></item><item><title>javascript的事件处理（一）——基础原理</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/01/16/2322608.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 16 Jan 2012 13:25:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/01/16/2322608.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; 事件是用户或者游览器自身执行的某种动作，诸如click，load，mouseover，都是时间的名称。响应某事件的函数就叫做事件处理程序（或者事件侦听器），事件处理程序的名字往往以'on'开头，比如click事件的事件处理程序是onclick，load时间的是onload。</p>
<p>&nbsp; &nbsp; &nbsp;为事件指定处理程序的方式有好几种：</p>
<p>&nbsp; &nbsp; &nbsp;<span style="font-size: 16px;"><strong>1. html事件处理程序</strong></span></p>
<div class="cnblogs_code">
<pre>&lt;button id = 'mybutton1' onclick = 'alert("button1")' &gt;Button1&lt;/button&gt;</pre>
</div>
<div class="cnblogs_code">
<pre>&lt;button id = 'mybutton2' onclick = 'handleClick()' &gt;Button2&lt;/button&gt;<br />&lt;script type = 'text/javascript'&gt;<br />   <span style="color: #0000ff;">function</span> handleClick(){<br />     alert("button2");  <br />  }<br />&lt;/script&gt;</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 这里特别一个问题，事件处理程中的代码在执行时，有权访问全局作用域中的任何代码。</p>
<p>&nbsp; &nbsp; &nbsp; 但在html中指定事件处处理程序有两个缺点：</p>
<p>&nbsp; &nbsp; &nbsp; 1. 时差问题。</p>
<p>&nbsp; &nbsp; &nbsp; 2. html与javascript代码紧密耦合</p>
<p>&nbsp; &nbsp; &nbsp; 第二点比较容易理解，这里重点讲下第一点，比如：</p>
<div class="cnblogs_code">
<pre>&lt;html&gt;<br />  &lt;head&gt;<br />    &lt;title&gt;Test UI Thread&lt;/title&gt;<br />     &lt;script type = 'text/javascript'&gt;<br />       <span style="color: #0000ff;">var</span> handleClick = <span style="color: #0000ff;">null</span>;<br />      setTimeout(<span style="color: #0000ff;">function</span>(){<br />       handleClick = <span style="color: #0000ff;">function</span> (){<br />        alert("button2");  <br />      }<br />      },10000)<br /><br />     &lt;/script&gt;<br />  &lt;/head&gt;  <br />  &lt;body&gt;<br />    &lt;div&gt;<br />      &lt;button id = 'mybutton2' onclick = 'handleClick()' &gt;Button2&lt;/button&gt;<br />    &lt;/div&gt;<br /><br />  &lt;/body&gt;<br />&lt;/html&gt;</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 在段代码在页面刚出现时点击按钮是没有用的，10s后再点击才能触发相应事件，这里因为用户可能会在hmtl元素一出现就触发，但当时的事件处理程序可能尚不具备执行条件，这样就会报错。</p>
<p>&nbsp; &nbsp; &nbsp;由于以上两个缺陷，好的开发者应该摒弃这种事件处理程序。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;<strong><span style="font-size: 16px;">2. DOM0级事件处理程序</span></strong></p>
<p>&nbsp; &nbsp; &nbsp;通过Javascript制定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。这种方法至今仍然为所有现代游览器所支持，一是因为简单，而是跨游览器。每个元素(包括window和document)都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。将这种属性的值设置为一个函数，就可以指定事件处理程序。</p>
<p>&nbsp; &nbsp; &nbsp;具体如下：</p>
<div class="cnblogs_code">
<pre>&lt;button id = 'mybutton3' &gt;Button3&lt;/button&gt; <br />&lt;script type = 'text/javascript'&gt;<br />    <span style="color: #0000ff;">var</span> bn3 = document.getElementById('mybutton3');<br />    bn3.onclick = <span style="color: #0000ff;">function</span>(){<br />      alert('button3');  <br />    }<br />&lt;/script&gt;</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;同样的道理，在这些代码运行以前不会指定事件处理程序，<br />&nbsp; &nbsp; &nbsp;特别强调的是，使用DOM0级方法指定的事件处理程序被认为是元素的方法，因此，这时候的事件处理程序在元素的作用域中运行；换句话说，程序中的this引用当前元素。比如还是上例，代码换成：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> bn3 = document.getElementById('mybutton3');<br />bn3.onclick = <span style="color: #0000ff;">function</span>(){<br />    alert(<span style="color: #0000ff;">this</span>.id);<span style="color: #008000;">//</span><span style="color: #008000;"> mybutton3 </span><span style="color: #008000;"><br /></span>}</pre>
</div>
<p>&nbsp; &nbsp; 这时就会显示&nbsp;mybutton3&nbsp;</p>
<p>&nbsp; &nbsp; 可以在事件处理程序中通过this访问元素的任何属性和方法，以这种方式添加的事件处理程序都在事件流的<span style="color: #0000ff;">冒泡阶段</span>被处理。</p>
<p>&nbsp; &nbsp; 当然只要像下面这样将事件处理程序属性设置为null，即可删除通过DOM0级方法指定的时间处理程序。</p>
<div class="cnblogs_code">
<pre>bn3.onclick = <span style="color: #0000ff;">null</span>;</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;<strong><span style="font-size: 16px;">3. DOM2级事件处理程序</span></strong></p>
<p>&nbsp; &nbsp;&ldquo;DOM2级事件&rdquo;定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventLister()。所有DOM节点中都包含这两个方法，并且他们都接受3个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕捉阶段调用事件调用事件处理程序，如果是false，表示在冒泡阶段调用事件处理程序。比如：</p>
<div class="cnblogs_code">
<pre>&lt;button id = 'mybutton4' &gt;Button4&lt;/button&gt; <br />&lt;script type = 'text/javascript'&gt;<br /><br />      <span style="color: #0000ff;">var</span> bn4 = document.getElementById('mybutton4');<br />      <span style="color: #008000;">/*</span><span style="color: #008000;"><br />       * 最后一个参数布尔值<br />       * true: 捕捉阶段调用事件处理程序<br />       * false: 在冒泡阶段调用事件处理程序<br />       * 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种游览器<br />       </span><span style="color: #008000;">*/</span><br />      bn4.addEventListener('click',<span style="color: #0000ff;">function</span>(){<br />        alert('button4');<br />        alert(<span style="color: #0000ff;">this</span>.id);<br />      },<span style="color: #0000ff;">false</span>);<br />      <br />  &lt;/script&gt;</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 通过addEventListener()添加的时间处理程序只能使用removeEventListener()来移除；移除时传入的参数和添加处理程序时使用的参数相同。这意味着通过addEventListener()添加的匿名函数将无法移除，比如：</p>
<div class="cnblogs_code">
<pre>      <span style="color: #0000ff;">var</span> bn4 = document.getElementById('mybutton4');<br /><br />      bn4.addEventListener('click',<span style="color: #0000ff;">function</span>(){<br />        alert('add event listener of button4');<br />      },<span style="color: #0000ff;">false</span>);<br />      <br />      <span style="color: #008000;">//</span><span style="color: #008000;">没有用</span><span style="color: #008000;"><br /></span>      bn4.removeEventListener('click',<span style="color: #0000ff;">function</span>(){<br />        alert('remove event listener of button4');  <br />      });</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 这段代码之所以没有起作用是因为实际上，第二个参数与addEventListener()中的那个是完全不同的函数。正确的做法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> hadler = <span style="color: #0000ff;">function</span>(){<br />    alert('add event listener of button4');<br />};<br /><br />bn4.addEventListener('click',hadler,<span style="color: #0000ff;">false</span>);<br /><span style="color: #008000;">//</span><span style="color: #008000;">有用      </span><span style="color: #008000;"><br /></span>bn4.removeEventListener('click',hadler,<span style="color: #0000ff;">false</span>);  </pre>
</div>
<p>&nbsp;</p>
<p><a href="http://www.cnblogs.com/lengyuhong/archive/2012/01/15/2322681.html">javascript的事件处理（二）&mdash;&mdash; 跨游览器编程</a><br /><br /></p>]]></description></item><item><title>autorestart 让nodejs代码即时生效</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/01/09/2317568.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 09 Jan 2012 15:01:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/01/09/2317568.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; 写nodejs代码时，要使代码生效，就必须重启服务，虽然也不麻烦，但时间长了也会觉得烦，因此有一个工具能帮助我时代码即时生效是件很不错的事情，这里介绍一款工具：autorestart</p>
<p>&nbsp; &nbsp; &nbsp; github地址：<a href="https://github.com/shimondoodkin/nodejs-autorestart">https://github.com/shimondoodkin/nodejs-autorestart</a></p>
<p>&nbsp; &nbsp; &nbsp; 比较可惜现在作者<span style="color: #0000ff;"><a href="https://github.com/shimondoodkin"><span style="color: #0000ff;">shimondoodkin</span></a>&nbsp;</span>&nbsp; 现在已经没怎么维护这个工程了，有部分内容在高版本的nodejs中已不能使用，但程序的大致架构还是在的，稍作修改即可使用。</p>
<p>&nbsp; &nbsp; &nbsp;使用方法：</p>
<p>&nbsp; &nbsp; &nbsp;下载代码之后，将nodejs.sh 和 autoexit.js 放到你项目工程代码的跟目录</p>
<p>&nbsp; &nbsp; &nbsp;以最简单的代码为例，工程目录autoRestart，自己的代码文件是server.js，代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> http = require('http');<br /><br /><span style="color: #0000ff;">var</span> app = http.createServer(<span style="color: #0000ff;">function</span>(req,res){<br />  <span style="color: #0000ff;">var</span> str = 'hello world';<br />  console.log(str);<br />  res.writeHead(200,{});<br />  res.end(str);<br />})<br />app.listen(9191,<span style="color: #0000ff;">function</span>(){<br />  console.log('server is listening on 9191');  <br />});</pre>
</div>
<p>&nbsp; &nbsp; 再将nodejs.sh 和 autoexit.js放到autoRestart目录下，即：</p>
<p><img src="http://pic002.cnblogs.com/images/2012/311780/2012010922455360.jpg" alt="" /></p>
<p>&nbsp; &nbsp; &nbsp;再在server中插入监控代码即可，最后server.js</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">require.paths.unshift(__dirname); //make local paths accessible</span><span style="color: #008000;"><br /></span><br /><br /><span style="color: #0000ff;">var</span> http = require('http');<br /><br /><span style="color: #0000ff;">var</span> app = http.createServer(<span style="color: #0000ff;">function</span>(req,res){<br />  <span style="color: #0000ff;">var</span> str = 'hello world';<br />  console.log(str);<br />  res.writeHead(200,{});<br />  res.end(str);<br />})<br />app.listen(9191,<span style="color: #0000ff;">function</span>(){<br />  console.log('server is listening on 9191');  <br />});<br /><br /><br /><span style="color: #008000;">//</span><span style="color: #008000;"> exit if any js file or template file is changed.</span><span style="color: #008000;"><br />//</span><span style="color: #008000;"> it is ok because this script encapsualated in a batch while(true);</span><span style="color: #008000;"><br />//</span><span style="color: #008000;"> so it runs again after it exits.</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">var</span> autoexit_watch = require('./autoexit').watch;<br /><span style="color: #008000;">//<br /></span><span style="color: #0000ff;">var</span> on_autoexit = <span style="color: #0000ff;">function</span> () { console.log('bye bye'); } <br />autoexit_watch(__dirname,".js", on_autoexit);<br /><span style="color: #008000;">//</span><span style="color: #008000;">autoexit_watch(__dirname+"/templates",".html", on_autoexit);</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 特别说明，第一行被注释掉，是因为require.paths在nodejs的高版本中已经不被兼容。</p>
<pre><span data-mce-="">  var</span> autoexit_watch = require('./autoexit').watch </pre>
<p>&nbsp; &nbsp; &nbsp;与项目源代码也稍有不同，请注意。</p>
<p>&nbsp; &nbsp; &nbsp;最后，只要编辑nodejs.sh的脚本去使用你的server.js文件即可。</p>
<p>&nbsp; &nbsp; &nbsp;启动程序：</p>
<div class="cnblogs_code">
<pre>./nodejs.sh</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;讲好了使用方法，再简单讲诉要这个项目的原理。</p>
<p>&nbsp; &nbsp; &nbsp;autoexit.js是监控目录下那些文件进行过改动，一旦文件发生过改动，程序要被关闭。</p>
<p>&nbsp; &nbsp; &nbsp;而nodejs.sh则是不断尝试启动server.js（对，你没有听错，就是不断尝试启动），当autoexit.js使程序关闭退出后，nodejs.sh就真正返回作用使程序重启。</p>
<p>&nbsp; &nbsp; &nbsp;两者相配合，就达到了使nodejs代码即时生效的作用。<br /><br />&nbsp;</p>
<p>&nbsp; &nbsp;&nbsp;</p>]]></description></item><item><title>《javascript高级程序设计》读书笔记——作用域</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/01/08/2316234.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sat, 07 Jan 2012 19:26:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/01/08/2316234.html</guid><description><![CDATA[<div><span><strong><br /> 执行环境：</strong></span></div>
<div><span>1.<span>&nbsp;</span><strong>执行环境（execution context）</strong>：定义了变量和函数有权访问的其他数据，决定了它们它们各自的行为</span></div>
<div>2. 每个执行环境都有一个与之关联的<strong>变量对象( variable object )</strong>，执行环境中定义的所有变量和函数都保存在这个对象中。</div>
<div>3. 我们编写的代码是无法访问到这个对象，但解析器在处理数据时会在后台使用它</div>
<div>&nbsp;</div>
<div>4. 全局执行环境是最外围的一个执行环境</div>
<div>5. 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数也随之销毁（全局执行环境知道应用程序退出&mdash;&mdash;例如关闭网页或者游览器&mdash;&mdash;时才销毁）</div>
<div>6. 每个函数在被调用时都会创建自己的执行环境，当执行流进入一个函数时，函数的环境会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，ECMAScript程序中的执行流正是由这个方便的机制控制着。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div><strong>作用域：</strong></div>
<div>1. 当代码在一个执行环境中执行时，会创建由变量对象构成的<strong>作用域链（scope chain）</strong></div>
<div>2. 作用域链的用途，是保证对执行环境有权访问的所有变量和函数的<strong>有序访问</strong></div>
<div>3. 作用域链前端，都是当前执行环境的代码所在环境的变量对象。</div>
<div>4. 如果这个环境是函数，则将其活动对象( activation object )作为变量对象，活动对象在最开始的时候只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）</div>
<div>5. 作用域链的下一个变量对象来自包含（外部）环境，而再一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终是作用域链的最后一个对象</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div><strong>标识符解析：</strong></div>
<div>标识符解析是沿着作用域链一级一级地搜索标识符的过程，搜索过程始终从作用域链的前端开始，然后逐级向后回溯，知道找到标识符为止（如果找不到标识符，通常会导致错误发生）</div>
<div>&nbsp;</div>
<div><strong>javascript中没有块级作用域</strong></div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">if</span>(<span style="color: #0000ff;">true</span>){<br />  <span style="color: #0000ff;">var</span> name = 'zhujiadun';<br />}<br />console.log(name);<span style="color: #008000;">//</span><span style="color: #008000;">zhujiadun</span></pre>
</div>
<br /><br /></div>
<div><strong>变量声明:</strong></div>
<div>一、</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span> add(num1,num2){<br />  <span style="color: #0000ff;">var</span> sum = num1 + num2;<br />  <span style="color: #0000ff;">return</span> sum;<br />}<br /><span style="color: #0000ff;">var</span> result = add(10,20);<br />console.log(result);<span style="color: #008000;">//</span><span style="color: #008000;">30</span><span style="color: #008000;"><br /></span>console.log(sum);<span style="color: #008000;">//</span><span style="color: #008000;">报错</span></pre>
</div>
</div>
<div>&nbsp;</div>
<div>二、</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">function</span> add(num1,num2){<br />  sum = num1 + num2;<br />  <span style="color: #0000ff;">return</span> sum;<br />}<br /><span style="color: #0000ff;">var</span> result = add(10,20);<br />console.log(result);<span style="color: #008000;">//</span><span style="color: #008000;">30</span><span style="color: #008000;"><br /></span>console.log(sum);<span style="color: #008000;">//</span><span style="color: #008000;">30</span></pre>
</div>
</div>
<div>&nbsp;</div>
<div>在使用var关键字声明变量时，这个变量将自动添加到举例最近的可用环境中</div>
<div>在编写javascript代码的过程中，不用var声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致错误。我们的建议是在初始化变量之前，一定要先声明；这样就可以避免类似情况</div>
<div>&nbsp;</div>
<div>用var声明变量，在函数外部，也就是说在window区域不加var确实是一样的，因为都会是全局的效果，而如果如含内部，加var就是局部变量，不加则是全局变量</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;</div>
<div><strong>查询标识符：</strong></div>
<div>逐级向上查找&nbsp;</div>
<div>当某个函数第一次被调用时，会创建一个执行环境（execution context）即相应的作用域链，并吧作用域链赋值给一个特殊的内部属性Scope，然后使用this，arguments和其他命名参数的值来初始化函数的活动对象( activation object )。但在作用域中，外部函数的活动对象始终处于第二位.....,依次类推</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>参考书：<a href="http://book.douban.com/subject/4886879/">《javascript高级程序设计》</a></div>
<div>&nbsp;</div>]]></description></item><item><title>用nodejs实现一个proxy</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/01/07/2316058.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sat, 07 Jan 2012 13:45:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/01/07/2316058.html</guid><description><![CDATA[<p>&nbsp; &nbsp; 由于nodejs自身的支持高并发和易用进行web特性，用其实现一个好的proxy再合适不过了。自己之前写过得几个</p>]]></description></item><item><title>JSON那些事</title><link>http://www.cnblogs.com/lengyuhong/archive/2012/01/07/2262390.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sat, 07 Jan 2012 12:01:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2012/01/07/2262390.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp;&nbsp;<span style="color: #0000ff;"><a href="http://www.json.org/json-zh.html"><span style="color: #0000ff;">JSON</span></a></span>(JavaScript Object Notation)是一种轻量级的数据格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是Javascript原生格式，这意味着在javascript中处理JSON数据不需要任何特殊的API或工具包，而且效率非常高。</p>
<p>&nbsp; &nbsp; &nbsp;JSON的结构如下：</p>
<ul>
<li><span style="font-size: 13px;">&ldquo;名称/值&rdquo;对的集合（A collection of name/value pairs）。不同的语言中，它被理解为<em>对象（object）</em>，纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</span></li>
<li><span style="font-size: 13px;">值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）</span></li>
</ul>
<p>&nbsp; &nbsp; &nbsp; 一个标准的json格式：</p>
<div class="cnblogs_code">
<pre>{"name":"jifeng","company":"taobao"}</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 总体而言，json是相对比较容易的理解和使用的，但同时存在很多的陷阱，如果不注意的话很容易掉进去，本文主要就是讲诉它容易让人犯错的地方。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; <span style="font-size: 16px;"><strong>一、json的的解析方法</strong></span></p>
<p>&nbsp; &nbsp; &nbsp; json的解析方法共有两种：1. eval() ; 2.JSON.parse()。具体使用方法如下</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> jsonstr = '{"name":"jifeng","company":"taobao"}';<br /><span style="color: #008000;">//</span><span style="color: #008000;">eval function</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">var</span> evalJson = eval('(' + jsonstr + ')');<br /><span style="color: #008000;">//</span><span style="color: #008000;"> JSON.parse function</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">var</span> JSONParseJson = JSON.parse(jsonstr);</pre>
</div>
<p>&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; 既然两者都能达到解析json的结果，但这两者有什么区别呢？我用以下的一个例子来进行说明：</p>
<p>&nbsp; &nbsp; 1. 用eval方法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> parse_json_by_eval = <span style="color: #0000ff;">function</span>(str){<br />    <span style="color: #0000ff;">return</span> eval('('+str+')');<br />}<br /><br /><span style="color: #0000ff;">var</span> value = 1;<br /><span style="color: #0000ff;">var</span> jsonstr = '{"name":"jifeng","company":"taobao","value":++value}';<br /><span style="color: #0000ff;">var</span> json1 = parse_json_by_eval(jsonstr);<br />console.log(json1);<br />console.log('value: '+ value);</pre>
</div>
<p>&nbsp; &nbsp; 执行结果：</p>
<div class="cnblogs_code">
<pre>{ name: 'jifeng', company: 'taobao', value: 2 }<br />value: 2</pre>
</div>
<p>&nbsp; &nbsp; 2. 用JSON.parse方法</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> parse_json_by_JSON_parse = <span style="color: #0000ff;">function</span>(str){<br />    <span style="color: #0000ff;">return</span> JSON.parse(str);<br />}<br /><br />value = 1;<br /><span style="color: #0000ff;">var</span> jsonstr = '{"name":"jifeng","company":"taobao","value":++value}';<br /><span style="color: #0000ff;">var</span> json2 = parse_json_by_JSON_parse(jsonstr);<br />console.log(json2);<br />console.log(value);</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;执行结果：</p>
<p>&nbsp; &nbsp; &nbsp;<span style="color: #0000ff;">不能顺利执行，报错</span></p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;前者能顺利执行，并修改了全局变量value的值，而后者报错了。从上例就可以明显地看出，eval在解析字符串时，会执行该字符串中的代码（这样的后果是相当恶劣的），如上例中，由于用eval解析一个json字符串而造成原先的value的值改变。《高性能Javascript》一书即指出：</p>
<table style="width: 80%;" border="0">
<tbody>
<tr>
<td>
<p><span style="background-color: #ffffff; color: #000000; font-family: 仿宋;"><em><span style="font-size: 14px;">警告：关于JSON和eval需要注意的是：在代码中使用eval是很危险的，特别是用它执行第三方的JSON数据（其中可能包含恶意代码）时，尽可能使用JSON.parse()方法解析字符串本身。该方法可以捕捉JSON中的语法错误，并允许你传入一个函数，用来过滤或转换解析结果。如果此方法以备Firfox 3.5 、IE8 及 Safari 4 原生支持。大多数javascript类库包含的JSON解析代码会直接调用原生版本，如果没有原生支持的话，会调用一个略微不那么强大的非原生版本来处理。</span></em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;<strong>一、'\' 对JSON的影响</strong></p>
<p>&nbsp; &nbsp; &nbsp; 由于JSON对象是从字符串解析而来，因此在了解 '\' 对JSON影响之前，我们先来了解 '\' 对字符串的影响。这里特别要强调的是在javascript中 ' 和 " 在表示字符串时是等价，比如'a' = "a"</p>
<p>&nbsp; &nbsp; &nbsp; 众所周知，由于String数据类型包含转义字符，比如 '\n'表示换行，'\b'表示空格等，因此用表示 he say &ldquo;hello&rdquo; 这个字符串时，需要用 '\' 这个特殊字符来表示,即"he say \"hello \"" 。在chrome的中console.log（）即可明显的看出。</p>
<p>&nbsp; &nbsp; &nbsp;<img src="http://pic002.cnblogs.com/images/2012/311780/2012010719574893.jpg" alt="" data-markzhi="registered" /></p>
<p>&nbsp; &nbsp; &nbsp;而JSON.parse()又是对字符串的真实含义进行解析，要表示 \ 必须要用"\\\\"表示，具体见下图：</p>
<p>&nbsp; &nbsp;&nbsp;<img src="http://pic002.cnblogs.com/images/2012/311780/2012010719401091.jpg" alt="" /></p>
<p>&nbsp; &nbsp; 在json中出现'\'时，必须万分小心，这的确是json中最容易出错的地方</p>
<p>&nbsp; &nbsp; 在顺便提一个小插曲：当我知道在json解析时需要用"\\\\"时表示"\"时，你用<span>JSON.parse('{"a":"a\\b"}')，竟然没有报错，难道我理解错了，细心的朋友应该看出来了，'\b'本身就是个转义字符，因此这里的第一个'\'是用来转义第二个'\' ，这样字符串就编程'a\b'('\b'是个转义字符)，所以JSON.parse()还是可以顺利解析的。</span></p>
<p>&nbsp; &nbsp; &nbsp; 对这个概念还是有点绕的，读者需要多想想，自己当时也是花了较长的时间来想这个问题。<br /><br /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>补充资料：</p>
<p>线上解析json网站：<span><a href="http://json.parser.online.fr/">http://json.parser.online.fr/</a></span></p>
<p><span><br /></span></p>]]></description></item><item><title>如何让nodejs同步操作</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/12/22/2290711.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 22 Dec 2011 14:45:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/12/22/2290711.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp;众所周知，异步是nodejs中得天独厚的特点和优势，但同时在程序中同步的需求（比如控制程序的执行顺序为：func1 -&gt; func2 -&gt;func3 ）也是很常见的。本文就是对这个问题记录自己的一些想法。</p>
<p>&nbsp; &nbsp; &nbsp;需要执行的函数：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> func1 = function(req,res,callback){<br />  setTimeout(function(){<br />    console.log(<span style="color: #800000;">'</span><span style="color: #800000;">in func1</span><span style="color: #800000;">'</span>);<br />    callback(req,res,<span style="color: #800080;">1</span>);  <br />  },<span style="color: #800080;">13000</span>);<br />}<br /><span style="color: #0000ff;">var</span> func2 = function(req,res,callback){ <br />  setTimeout(function(){<br />    console.log(<span style="color: #800000;">'</span><span style="color: #800000;">in func2</span><span style="color: #800000;">'</span>);<br />    callback(req,res,<span style="color: #800080;">2</span>);<br />  },<span style="color: #800080;">5000</span>);<br />}<br /><br /><span style="color: #0000ff;">var</span> func3 = function(req,res,callback){<br />  setTimeout(function(){<br />    console.log(<span style="color: #800000;">'</span><span style="color: #800000;">in func3</span><span style="color: #800000;">'</span>);<br />    callback(req,res,<span style="color: #800080;">3</span>);   <br />  },<span style="color: #800080;">1000</span>);<br />}</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 可以看出在func1，func2和func3中都是用了setTimeout函数，执行的时间分别为13秒，5秒和1秒。由于nodejs异步的特性，如果使用普通的函数调用方法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> req = <span style="color: #0000ff;">null</span>;<br /><span style="color: #0000ff;">var</span> res = <span style="color: #0000ff;">null</span>;<br /><span style="color: #0000ff;">var</span> callback = function(){};<br />func1(req,res,callback);<br />func2(req,res,callback);<br />func3(req,res,callback);</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;输出内容：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">in</span> func3<br /><span style="color: #0000ff;">in</span> func2<br /><span style="color: #0000ff;">in</span> func1</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;原因是因为nodejs是异步的，func2不会等func1执行完毕后再执行，而是立即执行（func3也是如此）。由于func3的运行时间最短而率先结束，func2次之，func1最后。但这明显不是我们想要的结果。怎么办？</p>
<p>&nbsp; &nbsp; &nbsp;<strong>解决办法一：callback</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">深层嵌套</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">var</span> req = <span style="color: #0000ff;">null</span>;<br /><span style="color: #0000ff;">var</span> res = <span style="color: #0000ff;">null</span>;<br /><br />func1(req,res,function(){<br />  func2(req,res,function(){<br />    func3(req,res,function(){<br />      process.exit(<span style="color: #800080;">0</span>);   <br />    })  <br />  });  <br />});</pre>
</div>
<p>&nbsp; &nbsp; &nbsp;这种方法虽然能快速的解决，但暴露的问题也很明显，一是代码维护不方面，二是代码的深层嵌套看起来很不舒服。这种方法并不可取。</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;<strong>解决方法二：递归调用</strong></p>
<div class="cnblogs_code">
<pre>function executeFunc(funcs,count,sum,req,res){<br />  <span style="color: #0000ff;">if</span>(count == sum){<br />     <span style="color: #0000ff;">return</span> ; <br />   }<br />   <span style="color: #0000ff;">else</span>{<br />    funcs[count](req,req,function(){<br />       count++;<br />       executeFunc(funcs,count,sum,req,res);<br />    });<br />   }  <br />}<br /><br /><span style="color: #008000;">//</span><span style="color: #008000;">同步调用</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">var</span> req = <span style="color: #0000ff;">null</span>;<br /><span style="color: #0000ff;">var</span> res = <span style="color: #0000ff;">null</span>;<br /><span style="color: #0000ff;">var</span> funcs = [func1,func2,func3];<br /><span style="color: #0000ff;">var</span> len = funcs.length;<br />executeFunc(funcs,<span style="color: #800080;">0</span>,len,req,res);</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 先将多个函数组成一个数组。再可以利用递归函数的特性，使程序按照一定的顺序执行。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; 解决方法三：调用类库</strong>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;随着nodejs的发展，响应的类库也越来越多。<span style="color: #0000ff;"><a href="https://github.com/creationix/step"><span style="color: #0000ff;">Step</span></a></span>和<span style="color: #0000ff;">async&nbsp;</span>就是其中不错的。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;1. Step的调用相对比较清爽：</p>
<div class="cnblogs_code">
<pre>Step(<br />  function thefunc1(){<br />    func1(<span style="color: #0000ff;">this</span>);<br />  },<br />  function thefunc2(finishFlag){<br />    console.log(finishFlag);<br />    func2(<span style="color: #0000ff;">this</span>);<br />  },<br />  function thefunc3(finishFlag){<br />    console.log(finishFlag);<br />  }<br />);</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;2.async 的&nbsp;<a href="https://github.com/caolan/async#series"><span style="color: #3366ff;">series</span></a>方法，就本例而言，它的调用方法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">var</span> req = <span style="color: #0000ff;">null</span>;<br /><span style="color: #0000ff;">var</span> res = <span style="color: #0000ff;">null</span>;<br /><span style="color: #0000ff;">var</span> callback = function(){};<br /><br />async.series(<br />  [<br />    function(callback){<br />      func1(req,res,callback);<br />    },  <br />    function(callback){<br />      func2(req,res,callback);<br />    },<br />    function(callback){<br />      func3(req,res,callback);  <br />    } <br />  ]<br />);</pre>
</div>]]></description></item><item><title>nodejs的一些局限</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/11/27/2265304.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 27 Nov 2011 13:29:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/11/27/2265304.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp;这段时间nodejs在国内发展是相当迅速的。这门语言&ldquo;非阻塞，异步，事件驱动&rdquo;的特点使其非常适合用于高并发量的web服务中。但正所谓&ldquo;人无完人&rdquo;，虽然nodejs有很多优点，但依然存在一些问题和缺陷。了解一门语言的优点很重要，但了解它的局限，并在现实开发中尽量规避，更加重要。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;一. 内存限制&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; nodejs是基于google的<a href="http://code.google.com/p/v8/">v8引擎</a>&nbsp;，而v8对单个node实例做了内存限制，在32位的系统中默认限制为512m，在64位的系统中则是1g。在游览器端，javascript有1G的内存肯定够了，但在web服务器端，1G就可能不够。以1G为例，每个连接都要占用100M的内存，这样服务最多只能建立10个连接，这显然是不行的。</p>
<p>&nbsp; &nbsp; &nbsp;据说nodeje为我们提供了一个执行参数用来改变这一个限制，执行语句：&nbsp; &nbsp;&nbsp;</p>
<div class="cnblogs_code">
<pre>node test.js &ndash;max-old-space-size=1000 </pre>
</div>
<p>&nbsp; &nbsp; &nbsp;但这样仍然是有限制的，32位是1g，64位为1.7g。</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;解决方案：</p>
<p>&nbsp; &nbsp; 1. 开始更多nodejs进程</p>
<p>&nbsp; &nbsp; 2. 限制连接数</p>
<p>　 3. 使用buffer。比如：<a href="http://zheye.org/asks/4da05d30fd503c24f9000001">http://zheye.org/asks/4da05d30fd503c24f9000001</a></p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; 二.GC（垃圾回收）&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 和java一样，nodejs的V8引擎是有系统进行垃圾回收的，而这是程序员所无法控制的，程序员只能标志这个对象不再使用(obj=null)，使得下次gc回收该对象的内存。更加可怕地是，v8在进行gc时，nodejs程序会暂停运行，这时向该程序发起的请求都会被忽略掉，造成服务不能访问。</p>
<p>　 &nbsp; 解决方案：</p>
<p>&nbsp; &nbsp; &nbsp;1. 写程序时尽量复用对象，而不是新生成对象。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>]]></description></item><item><title>svn教程</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/10/10/2116668.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Mon, 10 Oct 2011 13:42:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/10/10/2116668.html</guid><description><![CDATA[<p>&nbsp;</p>
<p>简介：</p>
<p>&nbsp; &nbsp; &nbsp;svn全名subversion，它是一个<strong>开源</strong>的<strong>版本控制系统</strong>，是一个跨平台的软件，支持大多常见的操作系统。</p>
<p>&nbsp; &nbsp; &nbsp;一. svn常见的项目目录结构</p>
<p>&nbsp; &nbsp; &nbsp;<span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>&nbsp;&nbsp;<span>&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-size: 16px;"><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>&nbsp; myproj/</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="border-collapse: separate; color: #000000; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;"><span style="font-size: 16px; text-align: -webkit-left;"><span style="font-size: 16px;"><span style="color: #000000;"><span style="border-collapse: separate; color: #000000; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |-- branches/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//分支目录</span><br /><span style="border-collapse: separate; color: #000000; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |-- tags/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //标签目录&nbsp;</span><br /><span style="border-collapse: separate; color: #000000; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |-- trunk/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //主干</span><br /><span style="border-collapse: separate; color: #000000; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |-- aa/</span><br /><span style="border-collapse: separate; color: #000000; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |-- a.txt</span><br /><span style="border-collapse: separate; color: #000000; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |--bb/</span><span style="border-collapse: separate; color: #000000; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|-- c.txt</span></span></span></span></span></p>
<p>&nbsp; &nbsp; &nbsp;二. 以下是些常用的指令和一些小技巧：</p>
<p style="font-size: 16px;" align="left"><span style="border-collapse: separate; color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;">&nbsp; &nbsp; 1. checkout（co）：建立个人工作空间，即本地的工作拷贝</span></span></span></span></span></span></span></p>
<p style="font-size: 16px;" align="left"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-size: small;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-size: small;"><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>&nbsp;&nbsp;&nbsp;<span>&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span>执行import之后，本地与服务器并没建立关联，只有执行checkout取出服务器内容后，才真正在本地建立了工作拷贝，和服务器建立了关联。</span></span></span></span></span></span></span></p>
<p style="font-size: 16px;" align="left"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-size: small;"><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>&nbsp;&nbsp;&nbsp;<span>&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span>命令：svn co<span>&nbsp;</span><a style="text-decoration: underline; color: #3966bf;" href="http://svn1.bj.corp.yahoo.com/repos/test/project1/trunk">http://svn1.bj.corp.yahoo.com/repos/test/project1/trunk</a><span>&nbsp;</span>proj1 （取出刚导入的项目trunk目录，你可以通过输入特定URL取出任意深度的子目录）</span></span></span></span></span></span></span></p>
<p style="font-size: 16px;" align="left"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-size: small;"><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>&nbsp;&nbsp;&nbsp;<span>&nbsp;</span>查看本地目录，proj1目录即是我的一个工作拷贝，其中每个目录都包括一个名为<strong>.svn管理目录</strong>，是用来管理工作拷贝的，<strong><span style="background-color: #ffff00;">不要修改</span></strong>。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p style="font-size: 16px;" align="left"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-size: small;"><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>&nbsp; &nbsp; 当要摆脱这个svn的约束时可以将这个项目目录下的全部 .svn 文件夹删除，可以试试以下shell指令</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div class="cnblogs_code">
<pre>find ./  -name '.svn'    |  xargs rm -rf</pre>
</div>
<p style="font-size: 16px;" align="left"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-size: small;"><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>&nbsp; &nbsp;&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p style="font-size: 16px;" align="left">&nbsp;</p>
<p style="font-size: 16px;" align="left"><span style="border-collapse: separate; color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: medium;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;">&nbsp; &nbsp; 2. add、delete（rm）：<span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="color: #000000;">修改工作拷贝的内容</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p style="font-size: 16px;" align="left">&nbsp;</p>
<div style="font-size: 16px;">
<ul>
<li>
<div align="left"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>修改文件aa/a.txt: 直接本地修改，无命令</span></span></span></span></span></span></span></div>
</li>
<li>
<div align="left"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>增加文件bb/b.txt：svn add bb/b.txt</span></span></span></span></span></span></span></div>
</li>
<li>
<div align="left"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>删除文件c.txt:&nbsp;&nbsp;&nbsp; svn delete c.txt</span></span></span></span></span></span></span></div>
<div align="left">&nbsp;</div>
</li>
</ul>
</div>
<p style="font-size: 16px;" align="left">&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 3. commit（ci）：提交我的修改</p>
<p style="font-size: 16px;" align="left"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-size: small;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-size: small;"><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span><span style="font-size: small;"><span style="color: #000000;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span style="font-family: 宋体;"><span>&nbsp;&nbsp;&nbsp;<span>&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>将上面步骤4中的本地修改提交到SVN库，命令：svn ci -m "modify files"，注 -m（注释信息）参数是必须的。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<p>资料：</p>
<p><a href="http://ishare.iask.sina.com.cn/f/12861361.html?retcode=0">svnbook-1.5-final-zh.pdf</a>&nbsp;&nbsp;（重点2.4 基本的工作循环）</p>
<script charset="utf-8" type="text/javascript">// <![CDATA[
(function(){
  var _w = 106 , _h = 58;
  var param = {
    url:location.href,
    type:'5',
    count:'1', /**是否显示分享数，1显示(可选)*/
    appkey:'', /**您申请的应用appkey,显示分享来源(可选)*/
    title:'', /**分享的文字内容(可选，默认为所在页面的title)*/
    pic:'', /**分享图片的路径(可选)*/
    ralateUid:'1613044525', /**关联用户的UID，分享微博会@该用户(可选)*/
	language:'zh_cn', /**设置语言，zh_cn|zh_tw(可选)*/
    rnd:new Date().valueOf()
  }
  var temp = [];
  for( var p in param ){
    temp.push(p + '=' + encodeURIComponent( param[p] || '' ) )
  }
  document.write('<iframe allowTransparency="true" frameborder="0" scrolling="no" src="http://hits.sinajs.cn/A1/weiboshare.html?' + temp.join('&') + '" width="'+ _w+'" height="'+_h+'"></iframe>')
})()
// ]]&gt;</script>]]></description></item><item><title>前端提示“页面正在载入”的功能实现</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/09/27/2193591.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Tue, 27 Sep 2011 13:48:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/09/27/2193591.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; 首先，当用户网络比较慢，或者服务器计算量比较大时，前端展示一个&ldquo;页面正在载入&rdquo;的提示，对用户体验是非常有用的，可以适度缓解用户的不耐烦的心情。这篇文章主要讲解&ldquo;页面正在载入&rdquo;功能的实现，内容比较基础。</p>
<p>&nbsp; &nbsp; &nbsp; 一般而言，它的基础原理就是将&ldquo;正在载入&rdquo;的提示放在一个div下，页面开始，但数据还没到时，这个div是可见的，当数据到位后，将这个div隐藏掉即可。当然这种方法往往配合ajax和jquery实现。最简单的例子如下：</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;</p>
<div class="cnblogs_code">
<pre>&lt;html&gt;<br />&lt;head&gt;<br />    &lt;title&gt;load时的图片&lt;/title&gt;<br />&lt;script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js"&gt;&lt;/script&gt;<br /><br />&lt;style type="text/css"&gt;<br />    #pageloading {<br />    position: fixed;<br />    _position: absolute;<br />    top: 40%;<br />    right: 50%;<br />    width: 100px;<br />    padding: 2px;<br />    text-align: center;<br />    background: #c44;<br />    color: #fff;<br />    z-index: 999;<br />    }<br />&lt;/style&gt;<br /><br />&lt;script type="text/javascript"&gt;<br /><br /><span style="color: #0000ff;">function</span> psHandler(data) {<br />    $('#pageloading').hide();<br />    <span style="color: #008000;">//</span><span style="color: #008000;"> show the detail data</span><span style="color: #008000;"><br /></span>}<br /><br />$(document).ready(<span style="color: #0000ff;">function</span>() {<br /><br />    $.ajax({ cache: <span style="color: #0000ff;">false</span><br />           , type: "GET" <br />           , dataType: "json"<br />           , url: "/get_data"<br />           , error: <span style="color: #0000ff;">function</span> () {<br />               <span style="color: #008000;">//</span><span style="color: #008000;">alert("error connecting to server");</span><span style="color: #008000;"><br /></span>             }<br />           , success: psHandler<br />           });<br /><br /><br />});<br /><br />&lt;/script&gt;    <br />    <br />&lt;/head&gt;<br />&lt;body&gt;<br /><br />&lt;/body&gt;<br />&lt;div id="pageloading" &gt;正在载入....&lt;/div&gt; <br />&lt;/html&gt;</pre>
</div>
<p>&nbsp; &nbsp; &nbsp; 这里代码相对而言还是相当简单的，特别要强调是css， position: fixed和_position: absolute;是为了兼容IE,z-index: 999;&nbsp;的作用是将这个图标出现在页面的最前端。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; 这种方法，还可以改成用图片来提示，只要将那段文字替换为以下的图片即可。　　</p>
<div class="cnblogs_code">
<pre>&lt;div id="pageloading" &gt;&lt;img src="loading.gif"/&gt;&lt;/div&gt; </pre>
</div>
<p></p>
<p>&nbsp; &nbsp; &nbsp;<img src="http://pic002.cnblogs.com/images/2011/311780/2011092721283995.gif" alt="" /></p>
<p></p>
<p></p>
<p>相关文章：</p>
<p><a href="http://www.cnblogs.com/qiantuwuliang/archive/2009/03/08/1406092.html">jquery实现的进度条</a></p>]]></description></item><item><title>CSS学习笔记</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/09/01/2162541.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 01 Sep 2011 14:34:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/09/01/2162541.html</guid><description><![CDATA[<p>　　本文主要记录自己学习CSS的一些历程和学习笔记，技术含量不高，仅对同样刚刚开始前端开发有些帮助。</p>
<p>&nbsp; &nbsp; &nbsp; 不错的学习资料：&nbsp;&nbsp;<a href="http://www.w3school.com.cn/css/index.asp">W3School</a>&nbsp;这个网站还是有挺多基础内容，相当不错。</p>
<p>&nbsp; &nbsp; &nbsp; 工具：<a href="http://www.w3school.com.cn/css/css_reference.asp">CSS的属性查询</a></p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;</p>]]></description></item><item><title>从雷军谈小米中的一些思考</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/08/29/2156832.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 28 Aug 2011 16:54:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/08/29/2156832.html</guid><description><![CDATA[<p style="text-align: center;">&nbsp;<img src="http://pic002.cnblogs.com/images/2011/311780/2011082900002185.jpg" alt="" /></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;这阵子雷军和小米手机相当的火，偶然看到<a href="http://v.youku.com/v_show/id_XMjk4MDEwMzcy.html">雷军的访谈</a>，相当收益，写下从中学到的东西。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 说来惭愧，近来之前自己对雷军这人还真是不怎了了解，只知道它是金山的老板，想不到它还是个非常成功的天使投资人，这几年还倒腾了好几家非常不错的工资。具体可见：</p>
<p>　　雷军是现任金山软件公司董事长，（前UC优视公司董事长，前金山公司总裁兼前CEO），雷军于1992年加入金山软件，1998出任金山软件首席执行官。在他的领导下，金山软件进一步将应用软件扩展至实用软件、互联网安全软件及网络游戏等领域，并在金山的全面互联网转型的过程中做出了重要贡献。2007年，金山软件上市后，雷军卸任金山软件总裁兼首席执行官职务，担任副董事长。2011年7月，雷军出任金山软件董事长。过去几年，雷军作为天使投资人，投资了凡客诚品、多玩、UCWEB(优视科技)、小米科技等多家创新型企业。2010年7月14日重返金山执掌金山网游与毒霸。2011年7月11日正式担任金山软件董事长一职。</p>
<p style="text-align: right;">&nbsp;&mdash;&mdash;来自百度百科</p>
<p>　　从雷军的谈吐和做事上可以看出，他的确是个非常有想法，而且有自己判断的人，这从他对互联网和手机的理解可见一斑。&nbsp; &nbsp; &nbsp;&nbsp;</p>
<p>　　&ldquo;传统互联网对传统产业的颠覆才刚刚开始.......互联网绝不是那简单的那几根网线，它是一种观念，用互联网的观念去重新思考传统产业时，你可以找到很多的结合点和想法，而互联网观点的四个关键词是：极致，专注，口碑和快&rdquo;</p>
<p>　　&ldquo;互联网讲的就是根据用户反馈不断坚持微创新，不断优化细节，这是很多传统产业所没有意识到的&rdquo;。</p>
<p>&nbsp; &nbsp; &nbsp;我在听到这段话之前，也一直觉得互联网只是&ldquo;工具&rdquo;，虽然这个工具已经整整改变了一个时代。从这个角度看，互联网这中&ldquo;专注，极致，口碑和快&rdquo;的特质是很容易颠覆很多原先牢不可破的东西。传统产业中原先的壁垒个门槛因为互联网的出现而大大降低，在此时如果用互联网的营销手段和技术往往能达到四两拨千斤的作用。这一点，真正值得自己再好好思考。</p>
<p></p>
<p>参考文章：</p>
<p><a href="http://content.businessvalue.com.cn/post/4273.html">雷军的方法论</a></p>
<p><a href="http://v.youku.com/v_show/id_XMjk4MDEwMzcy.html">雷军：小米揭秘</a></p>
<p></p>]]></description></item><item><title>IO的学习笔记 - 同步，异步，阻塞，非阻塞</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/08/18/2145009.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 18 Aug 2011 13:15:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/08/18/2145009.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp;这几天花了些时间研究IO的相关概念，记录下自己的一些学习思考。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;网上太多的文章都是你抄我，我抄你，真正是害人不浅。在这里特别介绍一篇好文：<span style="color: #3366ff;"><a href="http://blog.csdn.net/historyasamirror/article/details/5778378"><span style="color: #3366ff;">《IO - 同步，异步，阻塞，非阻塞（亡羊补牢篇）》</span></a>&nbsp;</span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;总结下自己的学习心得：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;一. 网络IO都必须经历的两个阶段：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;1 等待数据准备 (Waiting for the data to be ready)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;这两个阶段是所有IO模型都会经历的，他们的区别也体现在这两个阶段的不同。</p>
<p></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 二. 阻塞IO和非阻塞IO的区别</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 阻塞IO在操作全部进行完之前会一直block进程。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 非阻塞IO在内核准备数据时，会马上返回，不会block住进程</p>
<p></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 三. 同步与异步的区别</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 英文介绍：</p>
<p><span class="Apple-style-span" style="color: #333333; font-family: Arial; line-height: 26px;">&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>A synchronous I/O operation causes the requesting process to be blocked until that&nbsp;<span style="color: #ff0000;">I/O operation</span>&nbsp;completes;（同步）<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; An asynchronous I/O operation does not cause the requesting process to be blocked;</strong>&nbsp;（异步）</span></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 阻塞IO，非阻塞IO都是属于同步，这里是玩了一个&ldquo;文字游戏&rdquo;：</p>
<p><span class="Apple-style-span" style="color: #333333; font-family: Arial; line-height: 26px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &ldquo;有人可能会说，non-blocking IO并没有被block啊。这里有个非常&ldquo;狡猾&rdquo;的地方，定义中所指的&rdquo;IO operation&rdquo;是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block&rdquo;</span></p>
<p></p>
<p>&nbsp; &nbsp; &nbsp; 四. 举例</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp;最后，再举几个不是很恰当的例子来说明这四个IO Model:</p>
<p>&nbsp; &nbsp; &nbsp; 有A，B，C，D四个人在钓鱼：</p>
<p>&nbsp; &nbsp; &nbsp; A用的是最老式的鱼竿，所以呢，得一直守着，等到鱼上钩了再拉杆；(阻塞IO)</p>
<p>&nbsp; &nbsp; &nbsp; B的鱼竿有个功能，能够显示是否有鱼上钩，所以呢，B就和旁边的MM聊天，隔会再看看有没有鱼上钩，有的话就迅速拉杆；(非阻塞IO)</p>
<p>&nbsp; &nbsp; &nbsp; C用的鱼竿和B差不多，但他想了一个好办法，就是同时放好几根鱼竿，然后守在旁边，一旦有显示说鱼上钩了，它就将对应的鱼竿拉起来；(<span class="Apple-style-span" style="font-family: sans-serif; line-height: 24px;">IO多路复用(I/O multiplexing)</span>)</p>
<p>&nbsp; &nbsp; &nbsp; D是个有钱人，干脆雇了一个人帮他钓鱼，一旦那个人把鱼钓上来了，就给D发个短信。&nbsp;(异步IO)</p>]]></description></item><item><title>java的原始模型（Prototype）模式（一） 基本原理</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/08/04/2127957.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Thu, 04 Aug 2011 14:29:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/08/04/2127957.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp;前几天在学习javascript的面向对象编程，像我这种习惯于java式面向对象的人，在刚接触javascript时，还真是非常不适应，比如一个典型对象的结构：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">构造函数</span><span style="color: #008000;"><br /></span><span style="color: #0000ff;">function</span><span style="color: #000000;"> Complex(real ,imaginary){<br />    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.x </span><span style="color: #000000;">=</span><span style="color: #000000;"> real;<br />    </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.y </span><span style="color: #000000;">=</span><span style="color: #000000;"> imaginary;<br />    <br />}<br /><br /></span><span style="color: #008000;">//</span><span style="color: #008000;">实例方法</span><span style="color: #008000;"><br /></span><span style="color: #000000;">Complex.prototype.toString </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(){<br />    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> </span><span style="color: #000000;">"</span><span style="color: #000000;">{</span><span style="color: #000000;">"</span><span style="color: #000000;">+</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.x </span><span style="color: #000000;">+</span><span style="color: #000000;">"</span><span style="color: #000000;">,</span><span style="color: #000000;">"</span><span style="color: #000000;">+</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.y</span><span style="color: #000000;">+</span><span style="color: #000000;">"</span><span style="color: #000000;">}</span><span style="color: #000000;">"</span><span style="color: #000000;">;<br />}<br /><br />Complex.prototype.add </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(that){<br />    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> Complex(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.x</span><span style="color: #000000;">+</span><span style="color: #000000;">that.x,</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.y</span><span style="color: #000000;">+</span><span style="color: #000000;">that.y);<br /><br />}<br /><br /></span><span style="color: #008000;">//</span><span style="color: #008000;">类方法</span><span style="color: #008000;"><br /></span><span style="color: #000000;">Complex.sum </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000ff;">function</span><span style="color: #000000;">(a,b){<br />    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> Complex((a.x</span><span style="color: #000000;">+</span><span style="color: #000000;">b.x),(a.y</span><span style="color: #000000;">+</span><span style="color: #000000;">b.y))<br />}<br /><br /></span><span style="color: #008000;">//</span><span style="color: #008000;">类属性</span><span style="color: #008000;"><br /></span><span style="color: #000000;">Complex.ZERO </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> Complex(</span><span style="color: #000000;">0</span><span style="color: #000000;">,</span><span style="color: #000000;">0</span><span style="color: #000000;">);</span></pre>
</div>
<p>　　 &nbsp;它跟传统的java有着很大的不同，特别是<span class="Apple-style-span" style="font-family: 'Courier New'; font-size: 13px; line-height: 19px; white-space: pre; background-color: #f5f5f5;">prototype </span>这个关键字显得特别突兀，后来仔细研究了<a href="http://book.douban.com/subject/1214074/">《java与模式》</a>一书，发现这其实是模式中的原始模式（Prototype模式），它的基础思想就是&ldquo;通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象&rdquo;，它用到的方法是Object类中的clone方法（Java中的所有类都是从java.lang.Object类继承）。具体方法为：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">protected Object clone()</span></pre>
</div>
<p>　　而且要实现安全地使用复制，类必须实现Cloneable接口。而该接口只有一个作用，就是在运行时通知jvm可以安全地在这个类上使用clone()方法,通过调用这个clone()可以得到一个对象的复制。由于Object对象本身并不是实现Cloneable接口。因此所有没有实现Cloneable接口的类在调用clone()时会抛出CloneNotSupportedException 异常。用以下例说明</p>
<p>原型对象：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span><span style="color: #000000;"> </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> PandaToClone </span><span style="color: #0000ff;">implements</span><span style="color: #000000;"> Cloneable {<br />    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> height,weight,age;<br /><br />    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> PandaToClone(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> height, </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> weight) {<br />        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">();<br />        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.age </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #000000;">0</span><span style="color: #000000;">;<br />        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.height </span><span style="color: #000000;">=</span><span style="color: #000000;"> height;<br />        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.weight </span><span style="color: #000000;">=</span><span style="color: #000000;"> weight;<br />    }<br /><br />    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> getHeight() {<br />        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> height;<br />    }<br /><br />    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> setHeight(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> height) {<br />        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.height </span><span style="color: #000000;">=</span><span style="color: #000000;"> height;<br />    }<br /><br />    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> getWeight() {<br />        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> weight;<br />    }<br /><br />    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> setWeight(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> weight) {<br />        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.weight </span><span style="color: #000000;">=</span><span style="color: #000000;"> weight;<br />    }<br /><br />    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> getAge() {<br />        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> age;<br />    }<br /><br />    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> setAge(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> age) {<br />        </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.age </span><span style="color: #000000;">=</span><span style="color: #000000;"> age;<br />    }<br />    </span><span style="color: #008000;">/**</span><span style="color: #008000;">**<br />     * 原始模式最重要的一个函数<br />     </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> Object clone(){<br />        </span><span style="color: #008000;">//</span><span style="color: #008000;">创建一个本类的对象，不能够返回给调用者</span><span style="color: #008000;"><br /></span><span style="color: #000000;">        PandaToClone temp </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> PandaToClone(height,weight);<br />        temp.setAge(age);<br />        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> (Object)temp;<br />    }<br />    <br />    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String toString(){<br />        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> </span><span style="color: #000000;">"</span><span style="color: #000000;">{weight:</span><span style="color: #000000;">"</span><span style="color: #000000;">+</span><span style="color: #000000;">weight</span><span style="color: #000000;">+</span><span style="color: #000000;">"</span><span style="color: #000000;">,height:</span><span style="color: #000000;">"</span><span style="color: #000000;">+</span><span style="color: #000000;">height</span><span style="color: #000000;">+</span><span style="color: #000000;">"</span><span style="color: #000000;">,age:</span><span style="color: #000000;">"</span><span style="color: #000000;">+</span><span style="color: #000000;">age</span><span style="color: #000000;">+</span><span style="color: #000000;">"</span><span style="color: #000000;">}</span><span style="color: #000000;">"</span><span style="color: #000000;">;<br />    }<br />    <br />}</span></pre>
</div>
<p>调用主类：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span><span style="color: #000000;"> </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Client {<br />    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> </span><span style="color: #0000ff;">static</span><span style="color: #000000;"> PandaToClone thisPanda,thatPanda;<br />    <br />    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> </span><span style="color: #0000ff;">static</span><span style="color: #000000;"> </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){<br />        thisPanda </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> PandaToClone(</span><span style="color: #000000;">100</span><span style="color: #000000;">,</span><span style="color: #000000;">200</span><span style="color: #000000;">);<br />        thisPanda.setAge(</span><span style="color: #000000;">0</span><span style="color: #000000;">);<br />        <br />        thatPanda </span><span style="color: #000000;">=</span><span style="color: #000000;"> (PandaToClone)thisPanda.clone();<br />        System.out.println(</span><span style="color: #000000;">"</span><span style="color: #000000;">thispanda:</span><span style="color: #000000;">"</span><span style="color: #000000;">+</span><span style="color: #000000;">thisPanda);<br />        System.out.println(</span><span style="color: #000000;">"</span><span style="color: #000000;">thtapanda:</span><span style="color: #000000;">"</span><span style="color: #000000;">+</span><span style="color: #000000;">thatPanda);<br />    }<br />    <br />}</span></pre>
</div>
<p></p>
<p>执行结果：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">thispanda:{weight:</span><span style="color: #000000;">200</span><span style="color: #000000;">,height:</span><span style="color: #000000;">100</span><span style="color: #000000;">,age:</span><span style="color: #000000;">0</span><span style="color: #000000;">}<br />thtapanda:{weight:</span><span style="color: #000000;">200</span><span style="color: #000000;">,height:</span><span style="color: #000000;">100</span><span style="color: #000000;">,age:</span><span style="color: #000000;">0</span><span style="color: #000000;">}</span></pre>
</div>
<p>　 &nbsp;&nbsp;特别注意<span class="Apple-style-span" style="font-family: 'Courier New'; font-size: 13px; line-height: 19px; white-space: pre; background-color: #f5f5f5;">PandaToClone </span>类clone()这个函数的写法和<span class="Apple-style-span" style="font-family: 'Courier New'; font-size: 13px; line-height: 19px; white-space: pre; background-color: #f5f5f5;">Client</span>&nbsp;主函数的强制类型转换。　</p>
<p>&nbsp; &nbsp; &nbsp; 一般而言，clone()方法满足以下的描述：</p>
<p>&nbsp; &nbsp; &nbsp; 1. &nbsp;对任何对象x，都有：x.clone() != x 。换言之，克隆对象与原对象不是同一个对象。</p>
<p>&nbsp; &nbsp; &nbsp; 2. &nbsp;对任何的对象x。都有：x.clone().getClass() = x.getClass()，克隆对象与原对象的类型一样。</p>
<p></p>
<p></p>
<p></p>
<p></p>]]></description></item><item><title>TTServer(Tokyo Tyrant)的运行主流程</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/07/24/2115560.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 24 Jul 2011 11:46:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/07/24/2115560.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp;Tokyo Tyrant是用c语言实现了，而且是非面向对象，源代码只有函数。</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p></p>
<p>TTServer中的重要数据结构：<strong>TTSERV</strong>，<strong>TTREQ</strong>和<strong>TTSOCK</strong>，它们都在TT/ttutil.h中被定义，具体信息如下</p>
<p>1. <strong>TTSERV</strong>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> _TTSERV {                 </span><span style="color: #008000;">/*</span><span style="color: #008000;"> type of structure for a server </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> host[TTADDRBUFSIZ];               </span><span style="color: #008000;">/*</span><span style="color: #008000;"> host name </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> addr[TTADDRBUFSIZ];               </span><span style="color: #008000;">/*</span><span style="color: #008000;"> host address </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  uint16_t port;                         </span><span style="color: #008000;">/*</span><span style="color: #008000;"> port number </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  TCLIST </span><span style="color: #000000;">*</span><span style="color: #000000;">queue;                         </span><span style="color: #008000;">/*</span><span style="color: #008000;"> queue of requests </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  pthread_mutex_t qmtx;                  </span><span style="color: #008000;">/*</span><span style="color: #008000;"> mutex for the queue </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  pthread_cond_t qcnd;                   </span><span style="color: #008000;">/*</span><span style="color: #008000;"> condition variable for the queue </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  pthread_mutex_t tmtx;                  </span><span style="color: #008000;">/*</span><span style="color: #008000;"> mutex for the timer </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  pthread_cond_t tcnd;                   </span><span style="color: #008000;">/*</span><span style="color: #008000;"> condition variable for the timer </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> thnum;                             </span><span style="color: #008000;">/*</span><span style="color: #008000;"> number of threads </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">double</span><span style="color: #000000;"> timeout;                        </span><span style="color: #008000;">/*</span><span style="color: #008000;"> timeout milliseconds of each task </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> term;                             </span><span style="color: #008000;">/*</span><span style="color: #008000;"> terminate flag </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> (</span><span style="color: #000000;">*</span><span style="color: #000000;">do_log)(</span><span style="color: #0000ff;">int</span><span style="color: #000000;">, </span><span style="color: #0000ff;">const</span><span style="color: #000000;"> </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">, </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">);  </span><span style="color: #008000;">/*</span><span style="color: #008000;"> call back function for logging </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">opq_log;                         </span><span style="color: #008000;">/*</span><span style="color: #008000;"> opaque pointer for logging </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  TTTIMER timers[TTTIMERMAX];            </span><span style="color: #008000;">/*</span><span style="color: #008000;"> timer objects </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> timernum;                          </span><span style="color: #008000;">/*</span><span style="color: #008000;"> number of timer objects </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> (</span><span style="color: #000000;">*</span><span style="color: #000000;">do_task)(TTSOCK </span><span style="color: #000000;">*</span><span style="color: #000000;">, </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">, TTREQ </span><span style="color: #000000;">*</span><span style="color: #000000;">);  </span><span style="color: #008000;">/*</span><span style="color: #008000;"> call back function for task </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">opq_task;                        </span><span style="color: #008000;">/*</span><span style="color: #008000;"> opaque pointer for task </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> (</span><span style="color: #000000;">*</span><span style="color: #000000;">do_term)(</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">);               </span><span style="color: #008000;">/*</span><span style="color: #008000;"> call back gunction for termination </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">opq_term;                        </span><span style="color: #008000;">/*</span><span style="color: #008000;"> opaque pointer for termination </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />} TTSERV;</span></pre>
</div>
<p>&nbsp; &nbsp; &nbsp; &nbsp;TTSERV是ttserver服务器的一个实例，众多配置信息（host，port，线程数量）都在这里体现。具体ttserver该如何配置可以参考：<span class="Apple-style-span" style="color: #464646; font-family: verdana, 'ms song', Arial, Helvetica, sans-serif; font-size: 12px; line-height: normal;"><a id="PostsList1_rpPosts_TitleUrl_0" href="http://www.cnblogs.com/sunli/archive/2009/03/08/1406178.html" style="color: #464646; text-decoration: none; padding: 0px; margin: 0px;">Tokyo Tyrant（TTServer）系列-启动参数和配置</a></span>　</p>
<p></p>
<p>2. <strong>TTREQ&nbsp;</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> _TTREQ {                  </span><span style="color: #008000;">/*</span><span style="color: #008000;"> type of structure for a server </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  pthread_t thid;                        </span><span style="color: #008000;">/*</span><span style="color: #008000;"> thread ID </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> alive;                            </span><span style="color: #008000;">/*</span><span style="color: #008000;"> alive flag </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> _TTSERV </span><span style="color: #000000;">*</span><span style="color: #000000;">serv;                  </span><span style="color: #008000;">/*</span><span style="color: #008000;"> server object </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> epfd;                              </span><span style="color: #008000;">/*</span><span style="color: #008000;"> polling file descriptor </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">double</span><span style="color: #000000;"> mtime;                          </span><span style="color: #008000;">/*</span><span style="color: #008000;"> last modified time </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> keep;                             </span><span style="color: #008000;">/*</span><span style="color: #008000;"> keep-alive flag </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> idx;                               </span><span style="color: #008000;">/*</span><span style="color: #008000;"> ordinal index </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />} TTREQ;</span></pre>
</div>
<p>　　TTREQ具体指执行功能的线程</p>
<p>3.<strong>TTSOCK</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> {                         </span><span style="color: #008000;">/*</span><span style="color: #008000;"> type of structure for a socket </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> fd;                                </span><span style="color: #008000;">/*</span><span style="color: #008000;"> file descriptor </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> buf[TTIOBUFSIZ];                  </span><span style="color: #008000;">/*</span><span style="color: #008000;"> reading buffer </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">rp;                              </span><span style="color: #008000;">/*</span><span style="color: #008000;"> reading pointer </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> </span><span style="color: #000000;">*</span><span style="color: #000000;">ep;                              </span><span style="color: #008000;">/*</span><span style="color: #008000;"> end pointer </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> end;                              </span><span style="color: #008000;">/*</span><span style="color: #008000;"> end flag </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">double</span><span style="color: #000000;"> to;                             </span><span style="color: #008000;">/*</span><span style="color: #008000;"> timeout </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />  </span><span style="color: #0000ff;">double</span><span style="color: #000000;"> dl;                             </span><span style="color: #008000;">/*</span><span style="color: #008000;"> deadline time </span><span style="color: #008000;">*/</span><span style="color: #000000;"><br />} TTSOCK;</span></pre>
</div>
<p>　　TTSOCK即是指socket</p>
<p></p>
<p>&nbsp; &nbsp; &nbsp;介绍ttserver源码的文章：<a href="http://blog.csdn.net/pingnning/article/details/4676878">http://blog.csdn.net/pingnning/article/details/4676878</a></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>]]></description></item><item><title>ttserver的基础文章列表</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/07/22/2114464.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Fri, 22 Jul 2011 14:36:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/07/22/2114464.html</guid><description><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp;本文罗列了介绍ttserver的相关文章，比较基础，来源于网络并非原创，主要是为了方便自己的学习。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;ttserver的项目首页：<a href="http://fallabs.com/">http://fallabs.com/</a>&nbsp; （记得今年春天的时候域名还是<span class="Apple-style-span" style="color: #333333; font-family: arial, 宋体, sans-serif; font-size: 12px; line-height: 24px;"><a target="_blank" href="http://1978th.net/tokyocabinet/" style="text-decoration: underline; color: #136ec2;">http://1978th.net</a>&nbsp;，</span>不知为何写这篇文章时已更名）</p>
<p></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;ttserver基础：</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<a href="http://www.cnblogs.com/sunli/archive/2009/03/07/1405411.html">简介与安装</a></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;<a href="http://www.cnblogs.com/sunli/archive/2009/03/08/1406178.html">启动参数与配置</a></p>]]></description></item><item><title>淘宝主搜索体验</title><link>http://www.cnblogs.com/lengyuhong/archive/2011/07/03/2095661.html</link><dc:creator>lengyuhong</dc:creator><author>lengyuhong</author><pubDate>Sun, 03 Jul 2011 06:15:00 GMT</pubDate><guid>http://www.cnblogs.com/lengyuhong/archive/2011/07/03/2095661.html</guid><description><![CDATA[<div>&nbsp; &nbsp; &nbsp; 淘宝主搜做得还是相当不错，准确性也是比较高的。本篇文章主要想讲讲本人认为淘宝主搜索中做得不错而且值得学习的地方。</div>
<div>&nbsp;</div>
<div><strong><span style="font-size: 16px;">搜索主界面：</span></strong></div>
<div><img src="http://pic002.cnblogs.com/images/2011/311780/2011070117032837.jpg" /></div>
<div>&nbsp; &nbsp; &nbsp; 在常用的搜索中，下拉提示框是比较常用的方法，很多网站都有。而且处于电子商务中的场景，在搜索商品后跟宝贝数量也是很常见的方法，拍拍网和当当网都有这个功能（奇怪的是卓越竟然没有这个功能）。</div>
<div>&nbsp; &nbsp; &nbsp; 下拉提示框是个很有用的设置，既可以简化用户的输入，也可以起到引导用户输入的作用。第二种情况，一般发生在用户知道自己想要买什么东西，但不知道该输入怎么样的关键字去搜索时。后面的宝贝数量，也是起到引导用户的作用，毕竟宝贝数量越多，表示这个搜索词越热门，也越可能是你想要的结果。</div>
<div>&nbsp; &nbsp; &nbsp; &ldquo;同店购&rdquo;，是淘宝的一种特色搜索服务，针对的用户是那些希望能在同一家店铺买奇全部宝贝的用户（邮资考虑）。</div>
<div>&nbsp; &nbsp; &nbsp;&nbsp;</div>
<div></div>
<div><strong><span style="font-size: 16px;">搜索结果筛选页面</span></strong></div>
<div>&nbsp; &nbsp; <img src="http://pic002.cnblogs.com/images/2011/311780/2011070313481173.jpg" />&nbsp;&nbsp;</div>
<div>&nbsp; &nbsp; 从上图中<span style="color: #000080;">蓝色框<span style="color: #000000;">显示&ldquo;类目&rdquo;预测功能，由于淘宝中所买的宝贝是无所不包的，相应的，&ldquo;诺基亚&rdquo;这个关键词既可以说是手机类目下的品牌是诺基亚的手机，也可以是适用于&ldquo;诺基亚&rdquo;手机的手机挂件。所以在搜索中，判断用户真实想要的类目是非常必要的。这种类目预测更多的是依靠大量用户的真实点击数据得到。</span></span></div>
<div><span style="color: #000080;"><span style="color: #000000;"><span style="color: #ff0000;">&nbsp; &nbsp; &nbsp;红色框</span>显示是与用户搜索关键词相近的搜索词，这样当用户输入比较模糊时，可以精细用户的搜索；当用户输入不合适时，可以修正用户的输入。</span></span></div>
<div><span style="color: #000080;"><span style="color: #000000;"><span style="color: #00ff00;">&nbsp; &nbsp; &nbsp;绿色框</span>显示该类目下的属性。我个人不常用这个功能，觉得没什么用。</span></span></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>]]></description></item></channel></rss>